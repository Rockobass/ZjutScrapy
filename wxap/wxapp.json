{"title": "微信小程序开发中 var that =this的用法 ", "author": "Rolan", "pub_time": "2020-2-6 00:52", "content": "在微信小程序开发中，var that =this的声明很常见。举个例子，代码如下！示例代码11  //index.js  \r\n2  Page({  \r\n3   \r\n4   data: {  \r\n5    toastHidden: true,  \r\n6   },  \r\n7   \r\n8   loadData: function () {  \r\n9      var that = this//这里声明了that；将this存在that里面  \r\n10     wx.request({  \r\n11       url: 'test.php',  \r\n12       data: {a: 'a', b: 'b'},  \r\n13       header: {  \r\n14        'content-type': 'application/json'  \r\n15       },  \r\n16       success(res) {  \r\n17           that.setData({ toastHidden: false }) //这里使用了that，这样就可以获取Page({})对象  \r\n18        },  \r\n19      })  \r\n20    }  \r\n21  \r\n22  })在代码中第9行声明了var that =this；第17行使用了that。如果不声明var that =this，且that改成this，代码如下！示例代码21  //index.js  \r\n2   Page({  \r\n3  \r\n4    data: {  \r\n5     toastHidden: true,  \r\n6   },  \r\n7  \r\n8    loadData: function () {  \r\n9      wx.request({  \r\n10      url: 'test.php',  \r\n11      data: {a: 'a', b: 'b'},  \r\n12      header: {  \r\n13       'content-type': 'application/json'  \r\n14      },  \r\n15      success(res) {  \r\n16        this.setData({ toastHidden: false })  \r\n17       },  \r\n18      })  \r\n19   }  \r\n20  \r\n21  })此时运行代码就会报以下错误！从报错中得知setData这个属性读不到，为何读不到？这跟this关键字的作用域有关！this作用域分析：1.在Page({})里面，this关键字指代Page({})整个对象2.因此可以通过this关键字访问或者重新设置Page({})里data的变量3.然而在loadData函数中使用了wx.request({})API这个方法导致在wx.request({})里没办法使用this来获取Page({})对象4.虽然在wx.request({})里没法使用this获取Page({})对象，但是可以在wx.request({})外面先把this存在某个变量中，所以就有了var that =this 这个声明。此时that指代Page({})整个对象，这样子就可以在wx.request({})里使用that访问或者重新设置Page({})里data的变量"}
{"title": "小程序时代：如何跨多小程序开发协作？ ", "author": "Rolan", "pub_time": "2020-2-20 00:31", "content": "导语小程序端越来越多，\t跨平台开发框架逐渐成为开发小程序的主流 ，\t目前跨平台开发有较多的开源解决方案 ，本文介绍一种简单而有效的方法，解决复杂小程序的跨团队开发协作，希望对你有所帮助。背景目前市面上小程序端越来越多，跨平台开发框架逐渐成为开发小程序的主流。目前跨平台开发有较多的开源解决方案，比如美团点评的mpvue、滴滴的Chameleon、凹凸实验室的Taro等，都做得比较好。这些框架帮我们解决了一处开发，多处运行的难点。但是在复杂的业务场景中，最终落地也存在着许多困难，需要自己解决。以58房产的新房业务小程序为例，实际的业务场景中，既需要有独立承载功能的“58同城新房楼盘精选”小程序，也有依托于其他流量平台的入口，比如在“58同城”、“安居客买房”等都有相应的新房业务，同时还有交叉的业务场景，比如在同经纪人业务结合的“安居客经纪人网店”中展示新房楼盘。这其中既有微信小程序，也有百度小程序。这些业务有较多的共同点，比如基础功能逻辑是一致的，但是也存在很多差异性，比如商业逻辑，页面皮肤以及一些差异功能点。新房首页对比上图为三个小程序的首页对比，可以看到独立的小程序“58同城新房楼盘精选”集成了账号、城市、消息，在“58同城”和“安居客买房”这些能力则是依赖主体小程序。另外三个小程序之间还有些细微差别，但是楼盘相关的基础功能确是相同的。一处开发多处运行的难题作为业务方，我们希望业务代码也可以一处开发，到处运行。方案设计之时，我们的目标便是业务代码在同一仓库管理，同时方案具备较大的灵活性以适配各种环境。在上述的背景下，实际开发中会遇到如下困难：a) 各个小程序归属的开发团队不一样，使用的开发方案也不一样，有原生开发、wepy、Taro、mpvue等，意味着在源码层面是难以进行协作开发的；b) 业务方与平台方之间是跨团队协作，需要尽量减少耦合，提高协作效率，同时避免相互影响；c) 需要具备在各个小程序环境中的差异化开发方案；d) 所有业务代码同一地方管理，意味着会有不必要的代码，需要有机制保障最终的打包结果大小是最优的；e) 在不同平台小程序中，会依赖他们各自提供的基础能力，比如账户体系，消息等，这部分在各平台小程序中也存在着一定差异性；f) 在不同场景下需要具备不同的接入方案，支持微信插件方式接入平台小程序，也要支持业务分包方式接入平台小程序。整体架构设计本方案基于Taro 1.3版本实现，其他小程序框架也可使用相同的方法做改造。在现有Taro基础上，无法支持到一份源码打包成多个同类型的小程序，因此在现有配置层进行扩展处理，并添加适配层，对于各个小程序不同点进行处理，最终实现直接打包到多个不同的小程序中，整体的架构主要分为四层： a) 配置层，用于解决在不同场景下的差异化，包括环境变量、主题样式、页面配置等；b) 源码层，为具体的业务代码，常见方案，不做具体介绍；c) 适配层，用于对接不同方案下小程序提供的接口，并牟平不同小程序提供的接口差异，为源码层提供统一的接口；d) 打包层，与配置层相结合，用于打包最终交付结果；以新房为例的架构图：1.  配置层处理1） 打包脚本配置若要支持多小程序开发，需在package.json中增加scripts，用于区分环境。这里我们用的是cross-env这个包来设置，比如在打包58同城小程序时，加入环境变量WEAPPSOURCE=wbweapp。{    \"build:weapp\": \"taro build --type weapp\",    \"build:wbweapp\": \"cross-env WEAPPSOURCE=wbweapp taro build --type weapp\",    \"dev:wbweapp\": \"cross-env WEAPPSOURCE=wbweapp npm run build:weapp -- --watch\",}然后在`config/index.js`配置defineConstants，用来配置一些编译时的全局变量供代码中使用，这里的配置会用于做打包的差异化处理。大部分的差异化配置，我们都放到了编译时来进行配置，有助于降低代码打包后的大小。其原理是通过webpack的define-plugin和uglifyjs-webpack-plugin两个插件配合来删除掉不可达代码，保证不使用的代码不会被打包。config.defineConstants = {    WEAPPSOURCE: JSON.stringify(process.env.WEAPPSOURCE),    WBWEAPP: '\"wbweapp\"',    AJKWEAPP: '\"ajkweapp\"',}2） 差异性样式处理在现有业务中，需要同时支持58同城和安居客两个品牌。二者之间页面结构是一致的，但各自有些主题色，我们将这部分差异抽取出来，变成Sass变量，然后整合至一个scss文件中，通过编译时引入不同的scss文件，来达到切换主题的作用。这里主要是配置`config/index.js`中的`config.plugins.sass.resource` 。const sassConfig = {    wbweapp: '../wbweapp.scss',    ajkweapp: '../ajkweapp.scss'}config.plugins.sass.resource = path.resolve(__dirname, sassConfig[process.env.WEAPPSOURCE])3）差异化页面处理源码层中会包含所有场景下的全量页面，但每个场景所需的页面只是其中的一部分，需要做差异化处理。处理方法同上，略有差异点，通过编译打包时pages的配置不同，在`app.tsx`中的pages是决定引入哪些页面，我们通过传入环境变量找到对应的配置页面，实现按需配置打包。`config/index.js`中配置：const pagesConfig = {    wbweapp: ['pages/a'],    ajkweapp: ['pages/b']}config.defineConstants = {    PAGES: JSON.stringify(pagesConfig[process.env.WEAPPSOURCE])}`app.tsx`中配置：class App extends Component {    config: Config = {        pages: PAGES,    }}2.  适配层处理1） 差异化功能处理功能的差异化处理，使用配置层定义的全局变量来做，伪代码如下：import TabBar from '../components/tabbar';export default class _C extends Component {    render() {        return {(WEAPPSOURCE == WBWEAPP) && <TabBar/>}    }}这样写的话，当WEAPPSOURCE !== WBWEAPP时，TabBar组件不会被打包到最终代码中，wxml文件中TabBar的代码块也不会有。上面的import是不需要做特殊处理，打包时会分析依赖关系，没有被最终使用的文件不会被编译。2） 接口统一封装处理在各个平台方小程序中，通用功能都应该是统一管理的。比如用户信息，用户在58同城小程序内进行登录，各业务都能拿到统一的用户信息，而不是进入新房页面后再做一次新房的登录。这些功能，由平台方提供接口，供业务方调用。但各个平台存在差异性，这些差异性就由适配层做统一的封装，对业务开发提供一致的接口。比如获取城市信息：export const getCityInfo = () => {    if (WEAPP_SOURCE == WBWEAPP) {        city_info = WBIndex.WB.getCityInfo()    } else if (WEAPP_SOURCE == AJKWEAPP) {        city_info = AJKIndex.Common.getCityInfo();     } }原理解析通过以上介绍，已经解决了我们对差异化开发的要求，同时适配层将平台接口差异牟平，业务开发也不需要关心所处环境。大家可能比较好奇，所有的小程序代码都放在一起管理，最终打包出来的代码大小是不是最优的？主要是以下两点：1）  在开发中注意利用条件编译来删除不必要的代码；2）  在打包时做依赖分析及打包优化，业务层尽可能做更少的事情；依赖分析优化工作主要是由@tarojs/cli包来完成的，简化后的流程图如下：首先是解析入口文件`app.tsx`，通过两次语法转换，一次语法遍历，得到了依赖的样式文件、依赖的js文件、app的配置等，以及入口文件app.js。样式文件编译成最终的app.css，依赖的js文件，通过拷贝或生成，放到指定的目录中，app配置生成app.json。两次语法转换是不一样的，第一次是通用的语法转换，比如jsx语法的处理。第二次是差异化的转换，会根据当前转换的类型是入口文件、页面文件或组件文件做一些特殊处理。第二次转换时使用了babel-plugin-danger-remove-unused-import插件，会删除不必要的依赖引入。上文提到的TabBar组件，虽然是被引入了，但在不需要的场景下TabBar组件就不会被打包。这里需要注意引入的文件，不应该存在副作用。解析完入口文件后，会得到app配置的pages列表，页面文件列表循环通过同样的过程，得到页面的样式、js、配置等，以及所依赖的组件列表。组件文件的打包过程跟页面是基本一致的，区别点在于组件会依赖其他组件。理解了整个打包的流程，上面的问题答案就比较清晰了，不在pages配置里的页面是不会最终打包输出的，没有被依赖到的文件也是不会经过打包处理的。与平台小程序集成小程序最终的集成发布有三种方式：独立发布、插件集成、分包集成。多个小程序的不同集成方案1. 插件集成发布如果是通过小程序插件方式集成，平台小程序可以将接口统一挂载到插件的变量中，二者就桥接上了。插件的index.js设置（上文WBIndex即为引入的此文件）：module.exports = {WB: {},}平台小程序接口注入方法：const plugin = requirePlugin(\"xinfang\");plugin.WB = {    getCityInfo: function() {}}2. 分包集成发布如果是分包集成的话，可以考虑将接口直接挂载在App中。平台小程序接口注入方法（上文AJKIndex即为getApp()）：getApp().Common.getCityInfo = function() {}采用分包集成方案的话需要注意，因为双方是在各自仓库下分别开发的，最终需要和到一起进行打包发布。目前我们采用的方案是配置`config.outputRoot`将结果代码打包到平台小程序仓库中，通过git管理，再由平台小程序做发布。3.独立小程序发布方案跟分包集成发布是一致的，不过API由自己提供，也挂载在App中，同时扮演了平台方和业务方。实践经验分享a) 小程序包依赖的json文件的处理，比如插件需要有插件配置文件`plugin/plugin.json`。可通过配置`config.copy.patterns`指定需要拷贝的文件或者目录来实现；b) 小程序是插件和分包处理，在不同场景下的页面跳转路径是不一样的，但其实相对的路径是一致的，在于跳转前缀不同，可将页面跳转统一封装到适配层，根据环境变量适配不同的加上对应的前缀，当需要由插件切换到分包时，跳转部分仅需修改前缀，无需额外处理；问题解决前面提到一处开发多处运行的难题，得到了一一解决，整理如下：a) 源码层面无法进行跨团队协作开发？团队间分仓库开发，最终代码通过微信插件方式，或者分包方式进行集成。b) 业务方与平台方之间的如何解耦？通过统一的API，进行桥接，无其他耦合，API根据集成方式的不同，有不同的挂载方案。c) 如何进行差异化开发？针对样式差异化，配置差异化，功能差异化均给出了方法。d) 如何保证打包结果是最优的？尽可能的利用编译时的条件编译方法，排除不必要代码。e) 平台方接口的差异性如何牟平？增加了适配层，对业务提供一致的输入输出接口。f) 支持不同平台小程序的多种接入方案？支持了插件接入与分包接入。总结与规划本文介绍了在较复杂的小程序业务场景中，跨多小程序跨团队的协作方案，该方案帮助了新房业务在多小程序中的快速落地及迭代。在实现了“58同城”小程序中的新房业务接入后，我们又做了“58同镇”的新房业务对接。只需要“58同镇”小程序提供一致的基础能力接口，即可轻松接入。本文内容主要为业务经验积累，整体方案易于实施，带来的业务开发提效却是显著的，希望能帮助到大家。实际业务落地过程中，还有较多的细节需要处理，无法一一列举，欢迎提问或咨询。文中仅介绍了业务在微信小程序的实践情况，实际上在百度小程序以及H5也已有相应落地实践，具备了一定的通用性，可以放心使用。随着业务覆盖的范围越来越广，适配层会越来越复杂，不利于维护，更有效的方案是把业务实践总结为一套通用的接口标准，各个小程序按统一标准来实现API，业务方可以不关心所处环境的差异性，进一步提高跨团队开发的协作效率。 参考文献1. https://www.npmjs.com/package/cross-env2. https://nervjs.github.io/taro/docs/config.html3. https://webpack.js.org/plugins/define-plugin/4. https://www.npmjs.com/package/uglifyjs-webpack-plugin5. https://github.com/mishoo/UglifyJS2#compress-options 作者简介陈志庆 58同城资深研发工程师叶春喜 58同城高级研发工程师"}
{"title": "小程序实现图片模糊预加载--超详情教程 ", "author": "Rolan", "pub_time": "2020-2-20 00:41", "content": "导语\r\n最近在做的小程序项目设计大量图片的展示，小程序已经提供了图片的懒加载功能，但是由于图片本身比较大加上要展示的图片比较多，如何以一个比较友好的方式展示未加载完成的过程就是一个必须解决的问题了。\r\n思路\r\n由于小程序没有提供 Image 这个 js 对象，所以在小程序中实现预加载不能直接像原生js 一样，直接使用 new Image()创建一个图片对象，只能在视图层创建图片，通过onLoad事件监听图片加载完成。\r\n实现图片模糊加载的思路就是先加载一个目标图片的缩略图，缩略图的加载一般非常快可以忽略不计，缩略图加载完成之后以高斯模糊的形式展示，与此同时加载原图，原图加载完成后替代原缩略图，原图和缩略图需要设置相同的宽高。\r\n思路理清楚之后，开始码代码吧～\r\n\r\n由于项目使用了Taro框架，下面的代码写法是React的写法，原生或者其他框架也可以参考，没有太大的出入，思路都是一样的。\r\n\r\nimgLoader.js(以下为部分代码)\r\n       // 监听原图加载完成\r\n\ttoggleOriginLoaded() {\r\n\t\tthis.setState({\r\n\t\t\tloaded: true\r\n\t\t});\r\n\t}\r\n\t// 监听缩略图加载完成\r\n\ttoggleThumbLoaded() {\r\n\t\tthis.setState({\r\n\t\t\tthumbLoaded: true\r\n\t\t});\r\n\t}\r\n\t\r\n\trender() {\r\n\t\tlet { loaded, thumbLoaded } = this.state;\r\n\t\tlet { imgU, imgW, imgH } = this.props;\r\n\t\t// 根据传入的宽高设置缩略图和原图的宽高\r\n\t\tlet style = {\r\n\t\t\twidth: imgW + 'rpx',\r\n\t\t\theight: imgH + 'rpx'\r\n\t\t}\r\n\t\t\r\n\t\treturn (\r\n\t\t\t<Block>\r\n\t\t\t\t<Image\r\n\t\t\t\t\tclassName='image--not-loaded'\r\n\t\t\t\t\tstyle={Object.assign({ display: loaded ? 'none' : 'auto' }, style)}\r\n\t\t\t\t\tlazyLoad\r\n\t\t\t\t\tmode='aspectFill'\r\n\t\t\t\t\tonLoad={this.toggleThumbLoaded.bind(this)}\r\n\t\t\t\t\tsrc={compressImage(imgU, '10x' + parseInt(imgH * 10 / imgW))}\r\n\t\t\t\t/>\r\n\t\t\t\t{thumbLoaded && (\r\n\t\t\t\t\t<Image\r\n\t\t\t\t\t\tstyle={Object.assign({ display: loaded ? 'auto' : 'none' }, style)}\r\n\t\t\t\t\t\tlazyLoad\r\n\t\t\t\t\t\tclassName='image--is-loaded'\r\n\t\t\t\t\t\tmode='aspectFill'\r\n\t\t\t\t\t\tsrc={imgU}\r\n\t\t\t\t\t\tonLoad={this.toggleOriginLoaded.bind(this)}\r\n\t\t\t\t\t/>\r\n\t\t\t\t)}\r\n\t\t\t</Block>\r\n\t\t);\r\n\t}\r\n复制代码以上为主要视图层和逻辑层代码，其中compressImage函数是用来处理图片剪裁也就是缩略图的生成的，(ps：我们是用nginx实现的动态压缩，裁剪等功能，有需要的小伙伴可以自行搜索相关教程～)\r\n主要逻辑处理完成之后我们再来看模糊样式的处理，在此就要介绍一个 css 方法 blur（）。\r\nblur() CSS方法将高斯模糊应用于输出图片。它只有一个接受一个参数blur(radius)\r\n\r\nradius 表示模糊的半径，值为length。 它定义了高斯函数的标准偏差值，即屏幕上有多少像素相互融合; 因此，较大的值会产生更多模糊。 值为0会使输入保持不变。 该值为空则为0。（来自MDN）\r\n它可以生成类似毛玻璃样式的图片，如下图：\r\n\r\n\r\n了解了这个方法之后，就让我们来愉快的玩耍（写代码）吧～\r\n我们可以给这个效果添加一个小动画，让它看起来更有意思哦～\r\n.image--not-loaded{\r\n  // fix ios 缺少重绘的问题，添加无意义的transform强制触发重绘\r\n  transform: scale(1);\r\n  filter:blur(30px);\r\n}\r\n.image--is-loaded{\r\n  // fix ios 缺少重绘的问题，添加无意义的transform强制触发重绘\r\n  transform: scale(1);\r\n  filter:blur(20px);\r\n  animation: sharpen 0.8s both;\r\n}\r\n@keyframes sharpen {\r\n  0% {\r\n    filter: blur(20px);\r\n  }\r\n  100% {\r\n    filter: blur(0px);\r\n  }\r\n}\r\n复制代码需要注意的是blur方法在ios上会出现无法正确展示的问题，查询了相关文章后发现是因为ios 缺少重绘，就是ios不会根据这个代码重新绘制页面因此不能正确展示，如果要解决这个问题只要给他加上一条没有意义的transform，强制触发重绘就可以了～～\r\n效果图如下:\r\n5571f524-1f57-43da-"}
{"title": "微信小程序简易SEO优化 ", "author": "Rolan", "pub_time": "2020-2-26 00:31", "content": "半个月前给客户做了一个老小程序的 SEO 的初步优化计划，合计费时约 2 天左右，个中细节比较多， 这里举例两个比较重要，但是又不算难改的优化点。前端优化：跳转的 URL 可以直接打开简单可以测试为，分享出去的卡片，均可以直接打开（请务必测试是否登录，神坑）。这里牵扯到两个问题。页面渲染逻辑query 所携带的参数组件内 URL 问题第一个问题会牵扯到后端接口下发的内容，比如这样的场景：后端下发了一个列表数据，种种原因导致列表中就包含了点击列表后详情所要展示的所有内容，然后分享出去的是详情。这种情况基本是一个分享一个炸，自然微信小程序的页面爬虫也是个个 GG。这种情况就得前后端一起优化，独立一个 /x/detail 的接口，通过 id 等方式可获取详情的详情数据，并且注意，分享页务必接口设定无需登录。然后就是这个 id 之类的东西如何带进去，这就是第二个问题。有时候可能会因为一些特殊原因在 localStorage 或干脆直接挂在 getApp() 实例内存上，临时储存上个页面的 key，然后下个页面出来后在 onLoad 中拿这个 key 去使用。如果你有这个操作或者历史遗留问题，务必将其放在下个页面的 path 上，挂载在 query 后面。原因就是爬虫不会从上页面给你带内存数据，更不会验证本地缓存是否有效。第三个问题也很常见，因为小程序 SEO 中有一条是能用 navigator 则用 navigator， 而很有可能 nav 的功能被你封装在了一个组件内，常见比如 card 类组件，其本身就是一个 view（记得换成 navigator）下包含了其他元素。而点击操作之前可能是 bindtap 后根据组件携带的 item 计算出来的 path，而 item 是父级页面获取的接口 list 元素。如果出现这种情况，那么首先把组件的根 view 换成navigator，删除 bindtap 与相应事件，给 navigator 的 url 属性写上 item.url（或类似），然后在父级页面获取 list 的地方，多一个步骤，把 list 给 map 一下，或者 forEach 一下，给 list 的元素分别加上 url，这个 url 的计算在这里直接进行即可。服务端优化：使用页面路径推送能力这个就跟搜索引擎的站长提交链接地址一样，只不过这里提交的是小程序页面 path 与 query。多的不说，直接 NodeJS 代码参考下即可。function pushWeixinPages() {\r\n  // 默认起始 ID\r\n  let id = 0\r\n  // 这里放个本地文件保存上次推送的页面 ID，建议 ID 为数据库自增索引\r\n  // 本地保存是为了服务器重启不至于又来一遍\r\n  fs.readFile('./menu\\_id', async (error, menu\\_id) => {\r\n    console.log(error)\r\n    if(error) {\r\n      // 如果本地没有记录文件，则新建一个从零开始\r\n      fs.writeFileSync('./menu\\_id', '0')\r\n    } else {\r\n      id = menu\\_id.toString()\r\n      // 某页面数据库储存的数据\r\n      let push\\_sql = \\`\r\n        SELECT \\[selector\\] FROM \\[from\\] where \\[where\\] order by id;\r\n      \\`\r\n      // console.log(push\\_sql)\r\n      // 执行数据库语法，请自行封装\r\n      let ret = await util.sqlHandle(push\\_sql)\r\n      // 推送的页面数组\r\n      let pages = \\[\\]\r\n      ret.forEach(({ id }, idx) => {\r\n        // 添加每一项进数组\r\n        pages.push({\r\n          path: '/pages/detail/index',\r\n          query: \\`id=${id}\\`\r\n        })\r\n        // 最后一项的时候，本地存一下进度 ID\r\n        if(idx === ret.length - 1) {\r\n          fs.writeFileSync('./menu\\_id', menu.id)\r\n        }\r\n      })\r\n      // 获取微信 access\\_token，请自行封装\r\n      let { data } = await local.get('/wx/access\\_token')\r\n      // 推给微信\r\n      await axios.post(\\`https://api.weixin.qq.com/wxa/search/wxaapi\\_submitpages?access\\_token=${data.access\\_token}\\`, {\r\n        pages,\r\n      })\r\n      // 其他，愿意的话可以做做安全判断\r\n    }\r\n  })\r\n}其他语言参考处理即可，具体业务具体逻辑。其他优化方面顺便提一下，以下几方面：onShareAppMessage 时候配置 title 与 imagesitemapweb-view 不收录完事。"}
{"title": "源码级别高度定制小程序vant弹窗组件 ", "author": "Rolan", "pub_time": "2020-2-26 00:33", "content": "作为从事前端开发的你肯定见过不少的弹框组件，你可曾有想过要自己实现一个弹框组件库，又或者想完全定制化的使用各种标准UI框架中的弹框组件呢？今天这篇文章将会带着你解析这一系列疑问，以vant-weapp组件库为例，从开发标准的弹窗组件使用到高度定制复合自我审美的弹窗，再到完全研究清楚vant-weapp框架弹窗组件部分源码。一、vant-weapp弹窗组件介绍vant-weapp组件库是有赞团队开发的 一款灵活简洁且美观的小程序UI组件库 ，此文将以这个组件库的用法为标准，下文提及的弹框组件均指的是此组件库中的弹框。弹框分类vant-weapp中弹框主要分为**两大类：弹出层Popup和对话框Dialog，**弹出层一般是带有背景遮罩层和内容展示区域用于在不跳转页面情况下进行详情的展示作用，对话框多数用于带有详情展示的同时还带有希望用户确认等操作。如下图所示，图左为典型的Dialog，图右为典型的Popup。注册小程序组件在使用弹框组件之前记得在小程序的app.json文件中先注册组件，详细介绍见 快速上手 ，例如注册van-popup组件代码如下：// app.json\r\n\"usingComponents\": {\r\n  \"van-popup\": \"path/to/@vant/weapp/dist/popup/index\"\r\n}\r\n复制代码在项目中实际使用如下：在本文后续分析van-dialog源码中会发现在dialog的index.json中也定义过van-popup组件，但是我们要直接实行van-popup组件必须在小程序的配置文件app.json中按照上图方式进行定义，微信小程序官网说明过 自定义组件内部的引入组件只在该组件内生效注册完组件之后，就可以直接在小程序页面中使用这里注册的自定义组件，组件名称为这里 key ，例如：。二、Popup基本用法常见用法最常见的用法就是直接使用van-popup组件，通过组件的show属性来控制其是否展示，组件内部嵌套的其他组件或标签是popup组件的内容，如下所示：// wxml\r\n<button bindtap=\"showPopup\">展示弹出层</button>\r\n<van-popup\r\n\tshow=\"{{ show }}\"\r\n\tposition=\"top\"\r\n\tbind:close=\"onClose\"\r\n  closeable\r\n>内容</van-popup>\r\n\r\n// js\r\nPage({\r\n  data: {\r\n    show: false\r\n  },\r\n  showPopup() {\r\n    this.setData({ show: true });\r\n  },\r\n  onClose() {\r\n    this.setData({ show: false });\r\n  }\r\n});\r\n复制代码重点属性分析van-popup组件可以通过position属性的五个值： center、top、right、bottom、left 来快捷的控制是从哪个位置弹出，例如：上例中的弹框从上往下弹出可以通过round属性来控制弹窗内容是否显示圆角，closeable可以决定是否显示关闭弹框的图标按钮，例如：上例中的弹窗将不显示圆角，同时显示关闭按钮各种基本的弹窗形式如下：三、Dialog对话框基本用法对话框则是在popup弹出层的基础上添加了额外的内置的标题，快速确定按钮等组件，用于消息提示、消息确认等场景，下面看看其常见用法。常规用法——带标题最常规的用法就是直接使用van-dialog组件，通过组件的show属性来控制其是否展示，组件内部嵌套的其他组件或标签是dialog组件的内容，如下所示：// wxml\r\n<van-dialog\r\n  title=\"标题\"\r\n\tmessage=\"代码是写出来给人看的，附带能在机器上运行\"\r\n  show=\"{{ show }}\"\r\n  confirm-button-open-type=\"getUserInfo\"\r\n  bind:close=\"onClose\"\r\n  bind:getuserinfo=\"getUserInfo\"\r\n>\r\n  <image src=\"https://img.yzcdn.cn/1.jpg\" />\r\n</van-dialog>\r\n\r\n// js\r\nPage({\r\n  data: {\r\n    show: true\r\n  },\r\n  getUserInfo(event) {\r\n    console.log(event.detail);\r\n  },\r\n  onClose() {\r\n    this.setData({ close: false });\r\n  }\r\n});\r\n复制代码常规用法——无标题直接使用van-dialog组件，通过组件的show属性来控制其是否展示，组件内部嵌套的其他组件或标签是dialog组件的内容，不使用use-title-slot且不传递title属性，如下所示：// wxml\r\n<van-dialog\r\n  show=\"{{ show }}\"\r\n  confirm-button-open-type=\"getUserInfo\"\r\n  bind:close=\"onClose\"\r\n  bind:getuserinfo=\"getUserInfo\"\r\n>\r\n  <view class=\"message\">代码是写出来给人看的，附带能在机器上运行</view>\r\n</van-dialog>\r\n\r\n// js\r\nPage({\r\n  data: {\r\n    show: true\r\n  },\r\n  getUserInfo(event) {\r\n    console.log(event.detail);\r\n  },\r\n  onClose() {\r\n    this.setData({ close: false });\r\n  }\r\n});\r\n复制代码上述两种用法中的use-slot属性表示使用默认的slot（即van-dialog嵌套的wxml内容，比如此处的 ...）来作为内容输出，bind:getuserinfo等是使用的微信开发能力（即在点击确定按钮时候对调用微信平台API获取到对应的信息，此处是获取用户个人身份信息）函数式调用——confirm最常规的另一种用法就是直接使用 Dialog、Dialog.alert、Dialog.confirm 的方法快速打开弹窗组件，关闭弹框组件则通过 Dialog.close ，取消弹框的加载状态则使用 Dialog.stopLoading，组件内部嵌套的其他组件或标签是dialog组件的内容，如下所示：// wxml\r\n<van-dialog id=\"van-dialog\">\r\nimport Dialog from 'path/to/@vant/weapp/dist/dialog/dialog';\r\n\r\n// js\r\nDialog.alert({\r\n  title: \"标题\"\r\n  message: '代码是写出来给人看的，附带能在机器上运行'\r\n}).then(() => {\r\n  // on close\r\n});\r\n\r\n复制代码这里使用函数调用一定要注意在使用van-dialog的页面的wxml中一定需要写这个来使用组件，下文在分析dialog的源码中会讲到（卖个关子），或者你可以先猜一猜:blush::blush:上面三种van-dialog的常规使用方法的效果如下：四、Dialog进阶用法下面将会提供几个作者在实战中写出的Dialog对话框组件的实战用法使用use-title-slot定制标题<van-dialog\r\n  id=\"van-dialog\"\r\n  show=\"{{ dialogShow }}\"\r\n  message=\"资质原件拍照或扫描可以不加盖公章，复印件需盖章\\n\\n如是三证合一，则无需提供税务登记证、组织机构代码证\"\r\n  message-align=\"left\"\r\n  confirm-button-text=\"知道了\"\r\n  confirm-button-color=\"#EE712F\"\r\n  use-title-slot\r\n>\r\n  <view slot=\"title\" class=\" merchant-dialog__title\">\r\n    <view class=\"merchant-dialog__title-text\">开户前，请准备以下资料</view>\r\n    <van-icon name=\"cross\" size=\"40rpx\" class=\"merchant-dialog__title-icon\" bindtap=\"closeDialog\" />\r\n  </view>\r\n</van-dialog>\r\n// 样式部分的代码此处省略\r\n复制代码触发弹框显示handleButtonClick1: function () {\r\n  this.setData({\r\n  \tdialogShow: true\r\n  })\r\n},\r\n复制代码此例子如要使用了如下特性：use-title-slot\r\nconfirm-button-text、confirm-button-color\r\nvan-icon\r\n对应的效果如下：使用use-slot定制提示内容<van-dialog\r\n  id=\"van-dialog-2\"\r\n  use-slot\r\n  use-title-slot\r\n>\r\n  <view slot=\"title\" style=\"padding-bottom: 10px;\">\r\n    <van-icon name=\"close\" color=\"#fff\" size=\"30\" bindtap=\"closeDialog2\" />\r\n  </view>\r\n  <image class=\"image\" src=\"https://tva1.sinaimg.cn/large/0082zybply1gbylbcwm44j30rs13bdsg.jpg\" mode=\"aspectFit\"></image>\r\n</van-dialog>\r\n复制代码通过触发弹框显示handleButtonClick2: function () {\r\n  Dialog({\r\n    selector: '#van-dialog-2',\r\n    showConfirmButton: false,\r\n    closeOnClickOverlay: false,\r\n    className: 'dialog2',\r\n    width: '260px'\r\n  })\r\n},\r\n复制代码此例子如要使用了如下特性：使用 use-slot 表示使用默认的slot来内容来渲染到弹框主体内容位置渲染的内容为一张图片，以此来 实现幕帘curtain效果使用 className 这个 externalClasses 来用页面样式控制组件内部样式对应效果如下：使用css变量定义主题<van-dialog\r\n  id=\"van-dialog-3\"\r\n  use-title-slot\r\n>\r\n  <view slot=\"title\" style=\"color: #000;\">提示</view>\r\n  <view>\r\n    <view>为了给你推荐更合适的漫展～</view>\r\n    <view>请开启定位权限～</view>\r\n  </view>\r\n</van-dialog>\r\n复制代码通过触发弹框显示handleButtonClick3: function () {\r\n  Dialog({\r\n    selector: '#van-dialog-3',\r\n    showCancelButton: true,\r\n    cancelButtonTrext: '取消',\r\n    confirmButtonText: '去设置',\r\n    cancelButtonColor: '#C46B85',\r\n    confirmButtonColor: '#C46B85',\r\n    message: '为了给你推荐更合适的漫展～\\n请开启定位权限～',\r\n    confirmButtonOpenType: 'openSetting',\r\n    width: '260px',\r\n    className: 'dialog3'\r\n  })\r\n},\r\n复制代码外部样式类.dialog-index--dialog3 {\r\n  --dialog-background-color: rgba(255,255,255,0.8);\r\n  --popup-background-color: rgba(255,255,255,0.8);\r\n  --button-default-background-color: transparent;\r\n  color: #666;\r\n}\r\n复制代码此例子如要使用了如下特性：cancelButtonColor、confirmButtonColor\r\n--dialog-background-color\r\n对应效果如下：五、开发实际场景中的弹窗组件如果你仔细看过上面中的三种自定义方式的实现代码应该也可以根据UI需求实现自己的弹窗交互效果；这里我已经基于前面提到的三种用法来开发了几个实际场景中的弹框组件：实现幕帘curtain效果实现操作权限提示提示应用升级应用使用提示这部分的可以直接去看源码 github.com/JohnieXu/va…也可以扫码这个小程序二维码查看效果六、源码分析的前置条件在看完上面几种炫酷的弹框效果后，我们还是按照惯例研究下如此强大的弹框组件的源码。在研究弹框部分源码之前有必有分析一下一套完整UI框架所需要注意的框架级别的整体架构如何使用less工程化处理样式处理样式是所有UI框架比不可忽略的核心逻辑之一，在vant-weapp中对样式的处理主要分为以下三部分；源码对应结构如下图所示，使用less的mixins复用实现主题变量控制、公共样式抽离等。主题变量在var.less文件定义了框架所用到的全部的样式控制相关的变量，其中与弹框相关的部分源码如下：// Dialog\r\n@dialog-width: 320px;\r\n@dialog-small-screen-width: 90%;\r\n@dialog-font-size: @font-size-lg;\r\n@dialog-border-radius: 16px;\r\n@dialog-background-color: @white;\r\n@dialog-header-font-weight: @font-weight-bold;\r\n@dialog-header-line-height: 24px;\r\n@dialog-header-padding-top: @padding-lg;\r\n@dialog-header-isolated-padding: @padding-lg 0;\r\n@dialog-message-padding: @padding-lg;\r\n@dialog-message-font-size: @font-size-md;\r\n@dialog-message-line-height: 20px;\r\n@dialog-message-max-height: 60vh;\r\n@dialog-has-title-message-text-color: @gray-7;\r\n@dialog-has-title-message-padding-top: @padding-sm;\r\n复制代码源码： var.less此文件中的最终会转换成 css变量 ，并非像antd、iview等网页端框架中的样式处理那样编译成变量指向的值。根据css变量作用域的特性，可以在自定义组件的外部样式类中局部覆盖样式变量来改变组件内部的样式。通用样式像清除浮动、文字省略、1像素边框等通用的样式类的处理在mixin文件夹下清除浮动.clearfix() {\r\n  &::after {\r\n    display: table;\r\n    clear: both;\r\n    content: '';\r\n  }\r\n}\r\n复制代码使用常见的after伪类来实现清除浮动文件省略.multi-ellipsis(@lines) {\r\n  display: -webkit-box;\r\n  overflow: hidden;\r\n  text-overflow: ellipsis;\r\n  -webkit-line-clamp: @lines;\r\n  /* autoprefixer: ignore next */\r\n  -webkit-box-orient: vertical;\r\n}\r\n.ellipsis() {\r\n  overflow: hidden;\r\n  white-space: nowrap;\r\n  text-overflow: ellipsis;\r\n}\r\n复制代码使用less的函数封装了两个处理文字省略方法：单行省略、多行省略BEM命名如何工程化的注册自定义组件微信小程序官方提供了 Component构造方法 注册自定义组件，为了结合typescript给自定义组件提供更灵活强大的组件注册器对Component进行了下面的功能封装处理封装通用组件构造方法function VantComponent<Data, Props, Methods>(\r\n  vantOptions: VantComponentOptions<\r\n    Data,\r\n    Props,\r\n    Methods,\r\n    CombinedComponentInstance<Data, Props, Methods>\r\n  > = {}\r\n): void {\r\n  const options: any = {};\r\n  mapKeys(vantOptions, options, {\r\n    data: 'data',\r\n    props: 'properties',\r\n    mixins: 'behaviors',\r\n    methods: 'methods',\r\n    beforeCreate: 'created',\r\n    created: 'attached',\r\n    mounted: 'ready',\r\n    relations: 'relations',\r\n    destroyed: 'detached',\r\n    classes: 'externalClasses'\r\n  });\r\n  const { relation } = vantOptions;\r\n  if (relation) {\r\n    makeRelation(options, vantOptions, relation);\r\n  }\r\n  // 给所有组件添加默认外部样式类custom-class\r\n  options.externalClasses = options.externalClasses || [];\r\n  options.externalClasses.push('custom-class');\r\n  // 给所有组件添加默认behaviors\r\n  options.behaviors = options.behaviors || [];\r\n  options.behaviors.push(basic);\r\n  // map field to form-field behavior\r\n  if (vantOptions.field) {\r\n    options.behaviors.push('wx://form-field');\r\n  }\r\n  // 默认启用多slot支持、组件中允许全局样式修改\r\n  options.options = {\r\n    multipleSlots: true,\r\n    addGlobalClass: true\r\n  };\r\n  // 最终使用官网构造方法构造组件\r\n  Component(options);\r\n}\r\n复制代码源码： component.tsbehaviors复用共享逻辑behaviors 是微信小程序官方用于组件复用 data、methods 等属性方法的一种方式，和vue中的 mixins 小作用一致，vant-weapp中定义的 mixins 如下图所示:其中basic是所有自定义组件都复用的一个mxin，给所有自定义的组件提供了三个方法： $emit、 set 和 getRect 。$emit 封装了 triggerEvent 方法；set 封装 setData 方法为Promise形式；getRect 采用Promise方法用查找对应节点的boundingClientRect。源码如下：// basic.ts\r\nexport const basic = Behavior({\r\n  methods: {\r\n    $emit(...args) {\r\n      this.triggerEvent(...args);\r\n    },\r\n    set(data: object, callback: Function) {\r\n      this.setData(data, callback);\r\n\r\n      return new Promise(resolve => wx.nextTick(resolve));\r\n    },\r\n    getRect(selector: string, all: boolean) {\r\n      return new Promise(resolve => {\r\n        wx.createSelectorQuery()\r\n          .in(this)[all ? 'selectAll' : 'select'](selector)\r\n          .boundingClientRect(rect => {\r\n            if (all && Array.isArray(rect) && rect.length) {\r\n              resolve(rect);\r\n            }\r\n\r\n            if (!all && rect) {\r\n              resolve(rect);\r\n            }\r\n          })\r\n          .exec();\r\n      });\r\n    }\r\n  }\r\n});\r\n\r\n复制代码源码： basic.ts生命周期命名其实生命周期如何命名到不是很重要，vant-weapp对命名进行了转换主要基于以下两个原因：开发效率 ：vant-weapp源自适用于vue的UI组件库—— vant ，命名统一转换便于现有框架的逻辑复用使用成本 ：生命周期命名向主流MVVM框架靠近减轻使用者的学习成本、框架维护成本function mapKeys(source: object, target: object, map: object) {\r\n  Object.keys(map).forEach(key => {\r\n    if (source[key]) {\r\n      target[map[key]] = source[key];\r\n    }\r\n  });\r\n}\r\nmapKeys(vantOptions, options, {\r\n  data: 'data',\r\n  props: 'properties',\r\n  mixins: 'behaviors',\r\n  methods: 'methods',\r\n  beforeCreate: 'created',\r\n  created: 'attached',\r\n  mounted: 'ready',\r\n  relations: 'relations',\r\n  destroyed: 'detached',\r\n  classes: 'externalClasses'\r\n});\r\n复制代码源码： component.ts#L24通过 mapKeys 方法对 VantComponent 中传入的生命周期函数进行了转换，转换名生命周期名称与微信小程序一致自定义组件的样式隔离微信小程序自定义组件默认样式作用域的范围是为当前组件，也就是说组件文件夹下的wxss中的样式只对该文件夹下的wxml生效（除去标签名、ID选择器）这种以组件为单位进行样式隔离的模式类似于React框架中处理的组件样式的库 styled-components组件间样式共享要在组件之前共享样式或者让自定义组件接受外部样式，可行方案有如下几种：| styleIsolation属性配置 |page-isolated 表示在这个页面禁用 app.wxss ，同时，页面的 wxss 不会影响到其他自定义组件；page-apply-shared 表示在这个页面禁用 app.wxss ，同时，页面 wxss 样式不会影响到其他自定义组件，但设为 shared 的自定义组件会影响到页面；page-shared 表示在这个页面禁用 app.wxss ，同时，页面 wxss 样式会影响到其他设为 apply-shared 或 shared 的自定义组件，也会受到设为 shared 的自定义组件的影响。 | styleIsolation 选项从基础库版本 2.6.5 开始支持 | | --- | --- | --- | | addGlobalClass属性配置 | 表示页面 wxss 样式将影响到自定义组件，但自定义组件 wxss 中指定的样式不会影响页面 |小程序基础库版本 2.2.3 以上支持等价于styleIsolation: apply-sharedvant-weapp中使用的是此方案 ： addGlobalClass: 'true' ，默认的 styleIsolation: 'shared' 不生效 | | externalClasses外部样式类 | 组件的使用者可以指定这个样式类对应的外部样式名 ，对应样式名的样式在组件内部生效 |基础库 1.9.90 开始支持vant-weapp中也支持此方式推荐使用此方式来自定义vant-weapp的样式 | | class=\"~blue-text\"引用父组件样式 | 即使启用了样式隔离 isolated ，组件仍然可以在局部引用组件所在页面的样式或父组件的样式 | 基础库 2.9.2 开始支持 |使用总结使用vant-weapp组件库的使用者最佳的自定义组件样式的方式是： 采用外部样式类+CSS变量，在无相关CSS变量时才用自己的样式+ !important  确保样式优先级 ，在自定义组件中使用vant-weapp的组件时候的注意事项参照 样式覆盖 。自定义组件通信方案自定义组件通信主要包括 组件参数传递 和 事件监听 ，这两个功能都是微信小程序官网提供的；参数传递是由父传到子的单向传递，而事件监听则是相应原生事件或者自定义事件。自定义事件用于对组件的事件进行封装，自定义事件机制如下：这里在van-dialog组件使用位置监听bindclick事件，最终这个事件会在van-dialog组件内部的button的tap时被触发，后面源码分析中的自定义组件的自定义事件全部采用的此种模式。七、Popup弹出层组件源码分析组件部分源码结构popup组件部分源码结构如下：组件的命名规范与微信小程序自定义组件的规范相符合（README.md为组件的使用说明文档，用于生成官网的组件文档说明）。popup组件的配置文件标识当前的index为组件，通过 using-components 引入了 van-icon 和 van-overlay 组件，在对应的wxml中可以直接使用。组件主要逻辑弹出层组件主要分类 遮盖层 和 内容层 ，内容层嵌套在遮盖层内部来确保视觉上覆盖在遮盖层之上。遮盖层及事件遮盖层通过overlay、overlayStyle等组件属性来控制其是否显示以及遮盖层的样式等，遮盖的事件有 onClickOverlay ，通过$emit触发组件的自定义事件close。onClickOverlay() {\r\n  this.$emit('click-overlay');\r\n\r\n  if (this.data.closeOnClickOverlay) {\r\n    this.$emit('close');\r\n  }\r\n}\r\n复制代码关闭按钮及事件通过closable属性决定是否显示默认的关闭按钮，也可以通过关闭图标相关属性配置更改按钮样式，关闭按钮的事件有onClickCloseIcon，通过$emit触发组件的自定义事件close。onClickCloseIcon() {\r\n  this.$emit('close');\r\n},\r\n复制代码内容分发接受一个默认的slot，其位置根据传入的 position 参数不同有 top、right、bottom、left、center 五种，根据这五种位置参数有对应的五种不同的弹出位置和动画过渡动画使用transform来实现动画效果，根据 position 参数的五种情况有五种默认动画// popup/index.less\r\n.van-bottom-enter,\r\n.van-bottom-leave-to {\r\n  transform: translate3d(0, 100%, 0);\r\n}\r\n.van-top-enter,\r\n.van-top-leave-to {\r\n  transform: translate3d(0, -100%, 0);\r\n}\r\n.van-left-enter,\r\n.van-left-leave-to {\r\n  transform: translate3d(-100%, -50%, 0);\r\n}\r\n.van-right-enter,\r\n.van-right-leave-to {\r\n  transform: translate3d(100%, -50%, 0);\r\n}\r\n复制代码同时暴露了外部样式类可以用来自定义动画，这里动画阶段划分和vue相同，分类： enter、enter-active、enter-to、leave、leave-active、leave-to// popup/index.ts\r\nVantComponent({\r\n  classes: [\r\n    'enter-class',\r\n    'enter-active-class',\r\n    'enter-to-class',\r\n    'leave-class',\r\n    'leave-active-class',\r\n    'leave-to-class'\r\n  ],\r\n  ...\r\n}\r\n复制代码八、Dialog对话框组件源码分析组件部分源码结构dialog组件部分源码结构如下：结构同popup组件，不同点在于index.json使用了 van-popup、van-button 组件，以及多了dialog.ts这个暴露API函数调用方法的文件。组件布局结构dialog组件整体基于popup组件，在其默认slot中添加了顶部标题的slot和按钮组元素，大致结构如下源码结构：// dialog/index.wxml\r\n<van-popup\r\n  show=\"{{ show }}\"\r\n  ...\r\n>\r\n  <view\r\n    wx:if=\"{{ title || useTitleSlot  }}\"\r\n    class=\"van-dialog__header {{ message || useSlot ? '' : 'van-dialog--isolated' }}\"\r\n  >\r\n    <slot wx:if=\"{{ useTitleSlot }}\" name=\"title\" />\r\n    <block wx:elif=\"{{ title }}\"> {{ title }}</block>\r\n  </view>\r\n\r\n  <slot wx:if=\"{{ useSlot }}\" />\r\n  <view\r\n    wx:elif=\"{{ message }}\"\r\n    class=\"van-dialog__message {{ title ? 'van-dialog__message--has-title' : '' }} {{ messageAlign ? 'van-dialog__message--' + messageAlign : '' }}\"\r\n  >\r\n    <text class=\"van-dialog__message-text\">{{ message }}</text>\r\n  </view>\r\n\r\n  <view class=\"van-hairline--top van-dialog__footer\">\r\n    <van-button\r\n      wx:if=\"{{ showCancelButton }}\"\r\n      ...\r\n    >\r\n      {{ cancelButtonText }}\r\n    </van-button>\r\n    <van-button\r\n      wx:if=\"{{ showConfirmButton }}\"\r\n      ...\r\n    >\r\n      {{ confirmButtonText }}\r\n    </van-button>\r\n  </view>\r\n</van-popup>\r\n复制代码函数式调用实现在前面中通过Dialog函数调用来打开弹出框组件，实现函数式调用的核心思路主要是： 通过selectComponent(selector)方法查找（类似于查找DOM、Vue中查找组件实例）对页面中定义渲染好的dialog组件，手动更新其组件实例的数据。 ** Dialog方法定义如下：const Dialog: Dialog = options => {\r\n  options = {\r\n    ...Dialog.currentOptions,\r\n    ...options\r\n  };\r\n  return new Promise((resolve, reject) => {\r\n    const context = options.context || getContext();\r\n    const dialog = context.selectComponent(options.selector);\r\n    delete options.context;\r\n    delete options.selector;\r\n    if (dialog) {\r\n      dialog.setData({\r\n        onCancel: reject,\r\n        onConfirm: resolve,\r\n        ...options\r\n      });\r\n      queue.push(dialog);\r\n    } else {\r\n      console.warn('未找到 van-dialog 节点，请确认 selector 及 context 是否正确');\r\n    }\r\n  });\r\n};\r\n复制代码**函数式调用时候根据传入的options配置去更新找到的组件实例上的属性由微信小程序自定义组件限制不能更新slot，slot需要用组件嵌套来传入函数式调用中的options会有默认值强制覆盖掉van-dialog组件属性处传入的非id等其他属性，即函数调用的时通过组件传入的属性无效**Dialog.confirm确认弹窗调用方法Dialog.confirm({\r\n\tselector: '#van-dialog',\r\n\ttitle: '提示',\r\n\tmessage: '这里放置提示内容'\r\n})\r\n复制代码实现方式Dialog.confirm = options =>\r\n  Dialog({\r\n    showCancelButton: true,\r\n    ...options\r\n  });\r\n复制代码调用Dialog时候默认执行定了显示取消按钮，其他无区别Dialog.close关闭弹窗调用方法Dialog.close()\r\n复制代码实现方式Dialog.close = () => {\r\n  queue.forEach(dialog => {\r\n    dialog.close();\r\n  });\r\n  queue = [];\r\n};\r\n复制代码遍历内部缓存的所有调用Dialog方法找到的van-dialog组件实例，执行其close方法Dialog.setDefaultOptions更改对话框默认配置调用方法Dialog.setDefaultOptions(options)\r\n复制代码实现方式Object.assign(Dialog.currentOptions, options);\r\n复制代码通过Object.assign将传入的默认配置合并到内部Dialog.currentOptions配置上Dialog.resetDefaultOptions恢复对话框默认配置调用方法Dialog.resetDefaultOptions()\r\n复制代码实现方式Dialog.resetDefaultOptions = () => {\r\n  Dialog.currentOptions = { ...Dialog.defaultOptions };\r\n};\r\n复制代码恢复Dialog.currentOptions配置为Dialog.defaultOptions总结本文讲解了vant-weapp组件库中的弹框组件的基本用法、进阶用法、定制主题、自定义内容等用法，同时还更进一步的研究了vant-weapp组件中的popup组件、dialog组件的实现。也只有彻底弄懂了UI框架的封装思路我们才能更进一步的修改框架来定制化更复杂更贴合项目要求的各种组件，本文按照 由实用到进阶再到研究源码 的思路为各位研究框架源码提供另一种方法。下一步将会在vant-weapp弹框组件之上封装一系列实战的案例，期待你的关注与收藏。若此文对你有一点点帮助请点个赞鼓励下作者，毕竟原创不易:)首发自语雀： www.yuque.com/johniexu/fr…作者博客地址： blog.lessing.online/作者github： github.com/johniexu"}
{"title": "小程序-日历签到 ", "author": "Rolan", "pub_time": "2020-2-26 00:43", "content": "看小效果哈\r\n\r\n首先，我们要获取的无非就是每一个格子里面的数据。\r\n先获取月，然后点击月切换到另一个月，到了边界线的时候到了上/下年即可。\r\n那么，怎么获取月的数据呢，可以看到月第一天都是1开始，然后xx天，比如1月31天，我们把它枚举出来。\r\n但是月份受到年份影响，所以计算是否闰年就完成了。\r\n上代码\r\n获取这个月的7*5列表\r\nlet getMothList = (year, month) => {\r\n    var star = new Date(Date.UTC(year, month - 1, 1)).getDay()\r\n    let mn = getMothNum(year)[month - 1]\r\n    var res = []\r\n    var row = []\r\n    new Array(35)\r\n        .fill('')\r\n        .map((_, i) => i - star + 1)\r\n        .map(e => \r\n            (e > 0 && e <= mn)\r\n            ? ({\r\n                date: `${year}/${month}/${e}`,\r\n                number: e \r\n            })\r\n            : (null)\r\n        )\r\n        .forEach((item, i) => {\r\n            row.push(JSON.parse(JSON.stringify(item)))\r\n            if((i + 1) % 7 == 0){\r\n                res.push(row)\r\n                row = []\r\n            }\r\n        })\r\n    return res\r\n}\r\n复制代码然后获取月\r\nvar getMaxY = y =>  Boolean(\r\n\ty % 4 ==0 && y % 100 != 0 || y % 400==0\r\n)\r\nvar getAugNum = n => getMaxY(n) ? 29 : 28\r\n// --获取年对应的月份\r\nvar getMothNum = y => ([ 31, getAugNum(y), 31, 30,  31, 30, 31,31, 30, 31, 30, 31 ])\r\n复制代码我上面js就这些了（还差上下月切换的没说哈）\r\n但是少了中文的月份，有需要的这个可以再匹配\r\nvar mothZh = ['一','二','三','四','五','六','七','八','九','十','十一','十二'].map(e => e + '月')\r\n复制代码然后就是上下月月份了\r\n\r\n  up(e){\r\n    var data = e.currentTarget.dataset\r\n    if(data.data == '上'){\r\n      if(this.data.dateM > 1){\r\n        var dateM = this.data.dateM\r\n        var dateY = this.data.dateY\r\n        this.setDate(dateY, dateM - 1)\r\n      }else{\r\n        var dateY = this.data.dateY\r\n        this.setDate(dateY - 1, 12)\r\n      }\r\n    }\r\n  },\r\n  down(e){\r\n    var data = e.currentTarget.dataset\r\n    if(data.data == '下'){\r\n      if(this.data.dateM < 12){\r\n        var dateM = this.data.dateM\r\n        var dateY = this.data.dateY\r\n        this.setDate(dateY, dateM + 1)\r\n      }else{\r\n        var dateY = this.data.dateY\r\n        this.setDate(dateY + 1, 1)\r\n      }\r\n    }\r\n  },\r\n复制代码上下月操作好了就是更新数据了，更新数据的时候，因为小程序不能在view里面写逻辑，所以我们在mpa里面操作（这是我的业务逻辑，你们不用管他，我之所以放出来是方便大家查看）\r\n  setDate(dateY, dateM){\r\n    var date_list = getMothList(dateY, dateM)\r\n    .map(e => !e ? e : e.map(day => {\r\n      var cat_date = this.data.cat_date\r\n      return !day ? day : {\r\n        ...day,\r\n        className: this.data.chckin_list.indexOf(day.date) != -1 ? 'checkin' : '',\r\n        sign: day.date == [cat_date.y, cat_date.m, cat_date.d].join('/'),\r\n        maxToday: +(Date.UTC(day.date.split('/')[0], day.date.split('/')[1] - 1, +(day.date.split('/')[2])))\r\n          > Date.UTC(new Date().getFullYear(), new Date().getMonth(), new Date().getDate()),\r\n      }\r\n    }))\r\n    this.setData(({\r\n      dateY,\r\n      dateM,\r\n      date_list,\r\n    }))\r\n    // 获取月和修改的时候，获取签到列表\r\n    this.setSign(dateY, dateM)\r\n    // console.log(date_list)\r\n  },\r\n复制代码然后会注意到，这里有一个chckin_list，这个就是要渲染出来的啦。\r\nview\r\n<view class=\"week\">\r\n            <view class=\"flex\" wx:for=\"{{date_list}}\" wx:key=\"index\" wx:for-item=\"row\">\r\n                <view \r\n                class=\"day {{day.maxToday ? 'maxToday' : ''}}\" \r\n                wx:for=\"{{row}}\" wx:for-index=\"row_idx\" wx:for-item=\"day\" wx:key=\"row_idx\"\r\n                bind:tap=\"tapDay\"\r\n                data-day=\"{{day.date}}\"\r\n                >\r\n                    <block wx:if=\"{{day}}\">\r\n                        <text class=\"block to_day_block  {{day.sign ? 'select_date' : ''}}\" wx:if=\"{{toDay == day.date}}\">今</text>\r\n                        <text class=\"block  {{day.sign ? 'select_date' : ''}}\" wx:else>{{day.number}}</text>\r\n                    </block>\r\n                    <view wx:if=\"{{day.className}}\" class=\"{{day.className}}\">已签</view>\r\n                </view>\r\n            </view>\r\n        </view>\r\n复制代码上面是我的业务逻辑，其实只需要if，day就行了，因为除了空的，其他都需要渲染。但是一般业务也有是否签到啊，今天以后的灰色不可点击啊（这里没有不可点击是因为用css禁用点击）\r\n其他\r\n之所以没放css，大家css还是自己写吧，如果真有需要，在下面评论。\r\n哦， 如果要看效果，去小程序里面搜索，《初九背单词》，点击日历（一个是首页完成今日任务，一个是我的->背单词天数）\r\n（如果有需要，我可以说下签到后台是怎么做的，nodejs）\r\n--好了--\r\n就这样了，晚安"}
{"title": "写了一个小程序——无聊也是一种生产力 ", "author": "Rolan", "pub_time": "2020-2-27 00:34", "content": "​无聊也是一种生产力，最近不止无聊，还心烦，这种情况我只会做三种事情会比较开心，和某人出去玩、打游戏或者是写代码，前两种由于现实情况没办法实现，我就只能采用第三种方法了，并且这种时候写代码总可以写点自己想做的东西。小程序，很久之前写了一个非常简单的，当时就觉得微信小程序原生的语法真是的太复杂限制太多还不好用，尤其像我这种人，做出来的东西真的是丑的要死。这一次当然不会从头来了，果断 GitHub 找一找，不出所料，找到了我想做的东西的模板，甚至更应该说找到了还算不错的项目，Gitter，这是一个号称最漂亮的 GitHub 微信小程序，我表示同意，但是用着用着，发现其实有一点问题，无法满足我的需求：他的项目中 README 显示直接宕机了，不能显示 README 了，这个影响有点大，后来我看代码，猜测的原因是他把 markdown 的解析放到了服务器上，服务器挂掉了或者什么其他原因吧。打开小程序显示的就是 GitHub Trending，这个功能不错，但是在 Trending 中找到感兴趣的项目效率其实还是有点低的，很多时候我进去是看最近最火的现象级的项目是什么，比如 996.ICU，wuhan2020 这种，这个需求没有得到很好的满足。用这个小程序提 issue 的时候会自动加上一个小尾巴，内容是 Gitter 小程序的二维码，这个功能可以让使用者帮忙推广 小程序，没问题也是不错的方法，但是如果在一个 issue 下反复评论多次出现， 就会有一点重复的感觉。总的来说，这个小程序是一个很优秀的小程序，作为学习者的我，我要向其看起，针对不能满足需求的部分，那我就自己改写吧，License 是 Apache License 2.0，改写没问题。这里不想写具体的实现代码，如果有兴趣请 点击查看 改写后的项目，这里给出两张最后的截屏效果图吧：打开小程序，你第一眼看到的可能就是最近最应该知道的一个小程序（选择依据是积极、健康、热点、具有一定进步性，人工审核），本小程序可以查看自己所 Follow 人的活动，如果感兴趣也可以很方便的 star 或 fork，也可以查找 GitHub 所有的项目或用户（Gitter 中本来是有这个支持计划的，但是不知道为什么去掉了，我在近一周的平时使用多次用到了这个功能，还是很实用的），还可以分享给朋友，也支持 在公众号中插入直接跳转到某一个项目，在本篇中前后就有两个例子 ，非常欢迎大家使用，对于小尾巴，我的做法是可选而不是强制，为我宣传，我很感激，但是仅仅作为工具不强迫你。对于 README显示前三千个字符，基本应该可以了解这个项目是用来做什么的了，如果想查看全文可以到 Code 中查看，也是格式化好的，但是这样做就可以放在本地，并且有很好的效率，网络下载成功后几乎不用等待，我认为这样是一个比较好的用户体验。其他的界面我也都做了很多的相应优化，一些小细节，希望可以让你使用起来觉得还不错吧。开始这个项目时，由于我对小程序的写法，尤其是 Taro（本项目使用的一个框架）是从完全没听过的状态开始这个项目的，因此参考拷贝了大量的 Gitter 中代码，本项目是对 Gitter 项目的拙劣模仿。特此感谢！Gitter 项目可点击查看： Gitter后记：每次闲下来无聊我都会围绕 GitHub 学东西，这一次自我感觉是写关于 GitHub 最成功的一次了，原因也是因为这次时间最长，无聊就是生产力呀！武汉加油！中国加油！首发自公众号： RAIS"}
{"title": "小程序、H5登录授权、分享、支付流程 ", "author": "Rolan", "pub_time": "2020-1-14 00:32", "content": "前言对于前端来说，微信的 支付 、 分享 、 登录 是一定要掌握的，今天这篇文章，主要对这三方面的流程进行详细的介绍。主要内容如下：域名相关知识介绍该网站不安全，请不要输入密码\r\n微信小程序授权登录流程op=>operation: openid判断是否登录授权\r\nop2=>operation: 根据wx.login获取code\r\nop3=>operation: 调用服务端根据code换取openid\r\nop4=>operation: 通过用户授权，获取信息，存到数据库\r\nop->op2->op3->op4\r\n复制代码如果你从来没有阅读过小程序登录授权的文档，建议你看一下下面的地址：服务端官方文档 客户端文档nodejs + 小程序实现授权登录前端部分根据本地是否有userId判断是否登录，如果没有登录，则获取用户的openidonLoad() {\r\n   if(!this.data.userId) {\r\n       this.getSession()\r\n   }\r\n},\r\n getSession() {\r\n   wx.login({\r\n     success: (res) => {\r\n       if (res.code) {\r\n         app.get(Api.getSession, {\r\n           code: res.code\r\n         }).then(res => {\r\n           store.setItem('openid', res.openid)\r\n         })\r\n       }\r\n     }\r\n   })\r\n }复制代码点击授权按钮，发起登录请求。getUserInfo(e) {\r\n    let userInfo = e.detail.userInfo;\r\n    userInfo.openid = store.getItem('openid')\r\n    app.get(Api.login, {\r\n        userInfo\r\n    }).then(res => {\r\n        store.setItem('userId', res.data.userId)\r\n        this.setData({\r\n            userId: res.userId\r\n        })\r\n    })\r\n}复制代码服务端部分在 config 里面，定义公用的 appid 和 appsecretmodule.exports = {\r\n    wx: {\r\n        appId: 'wx0ef10432747d8f57',\r\n        appsecret: 'cc47a6127687e999a1dffa756ff83c0e'\r\n    },\r\n    mp: {\r\n        appId: 'wx0691f1dcf6e5e231',\r\n        appSecret: 'c7ed875e338120f15f49476a6596eb4f'\r\n    }\r\n}复制代码然后通过调用小程序 官方文档 的接口，获取到 appid 传给客户端let express = require('express');\r\nlet router = express.Router();\r\nlet request = require('request');\r\nlet config = require('./config');\r\nlet uril = require('./../../util/index')\r\nconfig = Object.assign({}, config.mp);\r\n\r\nrouter.get('/getSession', (req, res) => {\r\n    let code = req.query.code\r\n    if (!code) {\r\n        res.json(uril.handleFail('code不能为空', 10001))\r\n    }\r\n    let sessionUrl = `https://api.weixin.qq.com/sns/jscode2session?appid=${config.appId}&secret=${config.appSecret}&js_code=${code}&grant_type=authorization_code`;\r\n    request(sessionUrl, (err, response, body) => {\r\n        let result = util.handleResponse(err, response, body)\r\n        res.json(result)\r\n    })\r\n})复制代码登录接口 的编写// 小程序授权登录\r\nrouter.get('/login',async function(req,res){\r\n  let userInfo = JSON.parse(req.query.userInfo);\r\n  if (!userInfo){\r\n    // 如果接口没有信息，则返回错误信息\r\n    res.json(util.handleFail('用户信息不能为空',10002))\r\n  }else{\r\n    // 查询当前用户是否已经注册\r\n    let userRes = await dao.query({ openid: userInfo.openid},'users_mp');\r\n    if (userRes.code == 0){\r\n      // 如果已经注册，直接把查出来的信息返回给客户端\r\n      if (userRes.data.length >0){\r\n        res.json(util.handleSuc({\r\n          userId: userRes.data[0]._id\r\n        }))\r\n      }else{\r\n        // 如果这个用户之前没有注册，则在数据库插入用户信息\r\n        let insertData = await dao.insert(userInfo,'users_mp');\r\n        if (insertData.code == 0){\r\n          let result = await dao.query({ openid: userInfo.openid }, 'users_mp');\r\n          res.json(util.handleSuc({\r\n            userId: result.data[0]._id\r\n          }))\r\n        }else{\r\n          res.json(insertData);\r\n        }\r\n      }\r\n    }else{\r\n      res.json(userRes);\r\n    }\r\n  }\r\n})复制代码上述代码的 handleFail 和 handleResponse 是封装的对数据的统一处理，如果有兴趣，参见 github 地址。这里不展示代码。需要注意的是，这种实现方式，获取 openid 的行为放在后端实现了。如果放在前端实现也可以，但是会相对比较麻烦一点。此时，suerId就已经在数据库存储，并且在本地保存了，下次登录的时候，如果有userId存在就不需要再次登录了。H5的登录授权和分享流程H5的登录授权略有不同。如果用户登录授权页面，发现该用户没有登录授权，则需要跳转到授权页面。 官方文档 给出的流程如下：1 第一步：用户同意授权，获取code2 第二步：通过code换取网页授权access_token3 第三步：刷新access_token（如果需要）4 第四步：拉取用户信息(需scope为 snsapi_userinfo)5 附：检验授权凭证（access_token）是否有效在项目中代码如下：(这里代码没有实现刷新access_token和拉取用户信息)页面加载的时候，判断是否已经授权。mounted(){\r\n   this.checkUserAuth();\r\n },\r\nmethods:{\r\n// 检查用户是否授权过\r\ncheckUserAuth(){\r\n  let openId = this.$cookie.get('openId');\r\n  if(!openId){\r\n    // 如果没有登录授权，则跳转到微信提供的跳转页面。\r\n    window.location.href = API.wechatRedirect;\r\n  }else{\r\n  // 如果用户已经授权，则调用获取微信配置信息接口\r\n    this.getWechatConfig();\r\n  }\r\n},复制代码API.wechatRedirect:wechatRedirect:'/api/wechat/redirect?url=http%3A%2F%2Fm.51purse.com%2F%23%2Findex&scope=snsapi_userinfo',复制代码「注意」url地址需要 encodeURIComponent 编码才可以。m.51purse.com 需要与你在微信公众号后台配置的 授权域名 一致！nodejs 对登录授权回调接口的实现主要是拿到客户端的请求参数，请求微信提供的 接口// 用户授权重定向\r\nrouter.get('/redirect',function (req,res) {\r\n  let redirectUrl = req.query.url, scope = req.query.scope, callback = 'http://m.51purse.com/api/wechat/getOpenId';\r\n  cache.put('redirectUrl', redirectUrl);\r\n  // 获取到客户端带过来的数据，请求微信接口\r\n  let authorizeUrl = `https://open.weixin.qq.com/connect/oauth2/authorize?appid=${config.appId}&redirect_uri=${callback}&response_type=code&scope=${scope}&state=STATE#wechat_redirect`;\r\n  res.redirect(authorizeUrl);\r\n})\r\n复制代码当用户点击 确认授权 之后，会执行跳转 callbacl：http://m.51purse.com/api/wechat/getOpenId 。而这个接口也是node端实现的，具体内容如下：// 用code换取access_token的方法\r\nexports.getAccessToken = function(code){\r\n  let token_url = `https://api.weixin.qq.com/sns/oauth2/access_token?appid=${config.appId}&secret=${config.appSecret}&code=${code}&grant_type=authorization_code`;\r\n  return new Promise((resolve, reject) => {\r\n    request.get(token_url, function (err, response, body) {\r\n      let result = util.handleResponse(err, response, body);\r\n      resolve(result);\r\n    })\r\n  });\r\n}\r\n\r\n\r\n// 根据code获取用户的OpenId\r\nrouter.get('/getOpenId',async function(req,res){\r\n  let code = req.query.code;\r\n  console.log(\"code:\"+code);\r\n  if(!code){\r\n    res.json(util.handleFail('当前未获取到授权code码'));\r\n  }else{\r\n    // 用code换取access_token\r\n    let result = await common.getAccessToken(code);\r\n    if(result.code == 0){\r\n      // 换取access_token成功\r\n      let data = result.data;\r\n      let expire_time = 1000 * 60 * 60 * 2;\r\n      // 往客户端写入cookie：openId\r\n      res.cookie('openId', data.openid, { maxAge: expire_time });\r\n      let openId = data.openid;\r\n      let userRes = await dao.query({ 'openid': openId },'users');\r\n      if (userRes.code == 0){\r\n        if (userRes.data.length>0){\r\n          // 从数据库查找到用户信息后，回调到客户端的页面\r\n          let redirectUrl = cache.get('redirectUrl');\r\n          res.redirect(redirectUrl);\r\n        }else{\r\n          let userData = await common.getUserInfo(data.access_token, openId);\r\n          let insertData = await dao.insert(userData.data,'users');\r\n          if (insertData.code == 0){\r\n            // 从数据库查找到用户信息后，回调到客户端的页面\r\n            let redirectUrl = cache.get('redirectUrl');\r\n            res.redirect(redirectUrl);\r\n          }else{\r\n            // 返回错误信息\r\n            res.json(insertData);\r\n          }\r\n        }\r\n      }else{\r\n        // 返回错误信息\r\n        res.json(userRes);\r\n      }\r\n    }else{\r\n      // 返回错误信息\r\n      res.json(result);\r\n    }\r\n  }\r\n})\r\n复制代码「注意」：上面的代码为了简单，删除了一些不必要的代码，如有兴趣，访问gitHub。H5分享流程同样，如果你没有阅读过微信H5开发的 官方文档 ,建议你先阅读。关于分享，你应该阅读以下内容：当再次回调到页面的时候，从cookie已经拿到openId了。客户端会继续执行下面的代码。获取到服务端返回的配置信息，从而初始化分享的功能。在这之前，你需要 npm install wx-jssdk// 这个信息统一定义在api.js中，这里为了方便，放在前面，便于查看。\r\nAPI.wechatConfig: /api/wechat/jssdk\r\n\r\n\r\n// 获取微信配置信息\r\ngetWechatConfig(){\r\n  this.$http.get(API.wechatConfig+'?url='+location.href.split('#')[0]).then(function(response){\r\n    let res = response.data;\r\n    if(res.code == 0){\r\n      let data = res.data;\r\n      wx.config({\r\n        debug: true, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。\r\n        appId: data.appId, // 必填，公众号的唯一标识\r\n        timestamp: data.timestamp, // 必填，生成签名的时间戳\r\n        nonceStr: data.nonceStr, // 必填，生成签名的随机串\r\n        signature: data.signature,// 必填，签名\r\n        jsApiList: data.jsApiList // 必填，需要使用的JS接口列表\r\n      })\r\n      wx.ready(()=>{\r\n        util.initShareInfo(wx);\r\n      })\r\n    }\r\n  })\r\n}复制代码util/index.js 里面对分享的功能进行了封装。export default {\r\n  //获取浏览器地址栏参数值\r\n  getUrlParam(name){\r\n    let reg = new RegExp('(^|&)'+name+'=([^&]*)');\r\n    let r = window.location.search.substr(1).match(reg);\r\n    if(r!=null)return decodeURIComponent(r[2]);\r\n  },\r\n  initShareInfo(wx){\r\n    let shareInfo = {\r\n      title: 'xxxx', // 分享标题\r\n      desc: 'xxxx', // 分享描述\r\n      link: 'http://m.51purse.com/#/index', // 分享链接，该链接域名或路径必须与当前页面对应的公众号JS安全域名一致\r\n      imgUrl: '', // 分享图标\r\n    }\r\n    wx.onMenuShareAppMessage(shareInfo);\r\n    wx.onMenuShareTimeline(shareInfo);\r\n    wx.onMenuShareQQ(shareInfo);\r\n    wx.onMenuShareQZone(shareInfo);\r\n    // 下面两种方法为新的方法,上面的方法将会被淘汰。\r\n    wx.updateAppMessageShareData(shareInfo);\r\n    wx.updateTimelineShareData(shareInfo);\r\n  }\r\n}\r\n复制代码nodejs端对 /wechat/jssdk 接口的实现如下：// common.getToken()方法 获取基础接口的Token\r\n\r\nexports.getToken = function(){\r\n  let token = `https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=${config.appId}&secret=${config.appSecret}`;\r\n  return new Promise((resolve, reject)=>{\r\n    request.get(token, function (err, response, body) {\r\n      let result = util.handleResponse(err, response, body);\r\n      resolve(result);\r\n    })\r\n  })\r\n}\r\n----\r\n\r\nrouter.get('/jssdk',async function(req,res){\r\n  let url = req.query.url;\r\n  let result = await common.getToken();\r\n  if (result.code == 0){\r\n    let token = result.data.access_token;\r\n    let params = {\r\n      // 生成随机字符串\r\n      noncestr:util.createNonceStr(),\r\n      // 生成时间戳\r\n      timestamp:util.createTimeStamp(),\r\n      url\r\n    }\r\n      let str = util.raw(params);\r\n      console.log('str:::' + JSON.stringify(params))\r\n      let sign = createHash('sha1').update(str).digest('hex');\r\n      res.json(util.handleSuc({\r\n        appId: config.appId, // 必填，公众号的唯一标识\r\n        timestamp: params.timestamp, // 必填，生成签名的时间戳\r\n        nonceStr: params.noncestr, // 必填，生成签名的随机串\r\n        signature: sign,// 必填，签名\r\n        jsApiList: [\r\n          'updateAppMessageShareData',\r\n          'updateTimelineShareData',\r\n          'onMenuShareTimeline',\r\n          'onMenuShareAppMessage',\r\n          'onMenuShareQQ',\r\n          'onMenuShareQZone',\r\n          'chooseWXPay'\r\n        ] // 必填，需要使用的JS接口列表\r\n      }))\r\n    }\r\n  }else{\r\n    res.json(result);\r\n  }\r\n})复制代码以上代码主要获得基础的 token ,然后用基础 token 结合签名、时间戳、随机数等相关的参数，返回给客户端相应的参数。需要注意的是， 基础token 和 accessToken 的区别。建议 参考文章 。到此，微信H5接入jssdk实现分享就已经完成了。小程序支付小程序支付前端流程获取openId调起数字签名后端支付流程拼接常规参数生成签名拼接xml数据调用下单接口获取预支付Id：prepay_id生成支付sdk定义回调接口，接受微信支付消息支付的主要逻辑在服务端下面把服务端的流程通过代码的方式表述出来。首先在util中封装了一些支付需要的公共方法/**\r\n * 公共函数定义\r\n */\r\nlet createHash = require('create-hash');\r\nmodule.exports = {\r\n  // 生成随机数\r\n  createNonceStr(){\r\n    return Math.random().toString(36).substr(2,15);\r\n  },\r\n  // 生成时间戳\r\n  createTimeStamp(){\r\n    return parseInt(new Date().getTime() / 1000) + ''\r\n  },\r\n  // 生成签名\r\n  getSign(params, key){\r\n    let string = this.raw(params) + '&key=' + key;\r\n    let sign = createHash('md5').update(string).digest('hex');\r\n    return sign.toUpperCase();\r\n  },\r\n  // 生成系统的交易订单号\r\n  getTradeId(type='wx'){\r\n    let date = new Date().getTime().toString();\r\n    let text = '';\r\n    let possible = '0123456789';\r\n    for(let i=0;i<5;i++){\r\n      text += possible.charAt(Math.floor(Math.random() * possible.length))\r\n    }\r\n    return (type == 'wx'?'ImoocWxJuZi':'ImoocMpJuZi') + date + text;\r\n  },\r\n  // Object 转换成json并排序\r\n  raw(args){\r\n    let keys = Object.keys(args).sort();\r\n    let obj = {};\r\n    keys.forEach((key)=>{\r\n      obj[key] = args[key];\r\n    })\r\n    // {a:1,b:2} =>  &a=1&b=2\r\n    // 将对象转换为&分割的参数\r\n    let val = '';\r\n    for(let k in obj){\r\n      val += '&' + k + '=' +obj[k];\r\n    }\r\n    return val.substr(1);\r\n  }\r\n}复制代码下面是对支付的方法的封装，其中调用了util中的函数。客户端调用的就是下面的 order 方法。/**\r\n * 微信小程序、H5通用支付封装\r\n */\r\nlet config = require('./../pay/config')\r\nlet request = require('request')\r\nlet util = require('../../util/util')\r\nlet createHash = require('create-hash')\r\nlet xml = require('xml2js')\r\nconfig = config.mch;\r\nmodule.exports = {  \r\n  order: function (appid,attach, body, openid, total_fee, notify_url, ip){\r\n    return new Promise((resolve,reject)=>{\r\n      let nonce_str = util.createNonceStr();\r\n      let out_trade_no = util.getTradeId('mp');\r\n      // 支付前需要先获取支付签名\r\n      let sign = this.getPrePaySign(appid, attach, body, openid, total_fee, notify_url, ip, nonce_str, out_trade_no);\r\n      // 通过参数和签名组装xml数据，用以调用统一下单接口\r\n      let sendData = this.wxSendData(appid, attach, body, openid, total_fee, notify_url, ip, nonce_str, out_trade_no, sign);\r\n      let self = this;\r\n      let url = 'https://api.mch.weixin.qq.com/pay/unifiedorder';\r\n      request({\r\n        url,\r\n        method: 'POST',\r\n        body: sendData\r\n      }, function (err, response, body) {\r\n        if (!err && response.statusCode == 200) {\r\n          xml.parseString(body.toString('utf-8'),(error,res)=>{\r\n            if(!error){\r\n              let data = res.xml;\r\n              console.log('data:' + JSON.stringify(data));\r\n              if (data.return_code[0] == 'SUCCESS' && data.result_code[0] == 'SUCCESS'){\r\n                // 获取预支付的ID\r\n                let prepay_id = data.prepay_id || [];\r\n                let payResult = self.getPayParams(appid, prepay_id[0]);\r\n                resolve(payResult);\r\n              }\r\n            }\r\n          })\r\n        } else {\r\n          resolve(util.handleFail(err));\r\n        }\r\n      })\r\n    })\r\n  },\r\n  // 生成预支付的签名\r\n  getPrePaySign: function (appid, attach, body, openid, total_fee, notify_url, ip, nonce_str, out_trade_no) {\r\n    let params = {\r\n      appid,\r\n      attach,\r\n      body,\r\n      mch_id: config.mch_id,\r\n      nonce_str,\r\n      notify_url,\r\n      openid,\r\n      out_trade_no,\r\n      spbill_create_ip: ip,\r\n      total_fee,\r\n      trade_type: 'JSAPI'\r\n    }\r\n    let string = util.raw(params) + '&key=' + config.key;\r\n    let sign = createHash('md5').update(string).digest('hex');\r\n    return sign.toUpperCase();\r\n  },\r\n  // 签名成功后 ，根据参数拼接组装XML格式的数据，调用下单接口\r\n  wxSendData: function (appid, attach, body, openid, total_fee, notify_url, ip, nonce_str, out_trade_no,sign) {\r\n    let data = '<xml>' + \r\n      '<appid><![CDATA[' + appid + ']]></appid>' + \r\n      '<attach><![CDATA[' + attach + ']]></attach>' + \r\n      '<body><![CDATA[' + body + ']]></body>' + \r\n      '<mch_id><![CDATA[' + config.mch_id + ']]></mch_id>' + \r\n      '<nonce_str><![CDATA[' + nonce_str + ']]></nonce_str>' + \r\n      '<notify_url><![CDATA[' + notify_url + ']]></notify_url>' + \r\n      '<openid><![CDATA[' + openid + ']]></openid>' + \r\n      '<out_trade_no><![CDATA[' + out_trade_no + ']]></out_trade_no>' + \r\n      '<spbill_create_ip><![CDATA[' + ip + ']]></spbill_create_ip>' + \r\n      '<total_fee><![CDATA[' + total_fee + ']]></total_fee>' + \r\n      '<trade_type><![CDATA[JSAPI]]></trade_type>' + \r\n      '<sign><![CDATA['+sign+']]></sign>' + \r\n    '</xml>'\r\n    return data;\r\n  },\r\n  getPayParams:function(appId,prepay_id){\r\n    let params = {\r\n      appId,\r\n      timeStamp:util.createTimeStamp(),\r\n      nonceStr:util.createNonceStr(),\r\n      package: 'prepay_id=' + prepay_id,\r\n      signType:'MD5'\r\n    }\r\n    let paySign = util.getSign(params,config.key);\r\n    params.paySign = paySign;\r\n    return params;\r\n  }\r\n}复制代码最后定义 /pay/payWallet 的支付接口，里面调用公用的order方法。// 小程序支付\r\nrouter.get('/pay/payWallet',function(req,res){\r\n  let openId = req.query.openId;//用户的openid\r\n  let appId = config.appId;//应用的ID\r\n  let attach = \"小程序支付课程体验\";//附加数据\r\n  let body = \"欢迎学习慕课首门支付专项课程\";//支付主体内容\r\n  let total_fee = req.query.money;//支付总金额\r\n  let notify_url = \"http://localhost:3000/api/mp/pay/callback\"\r\n  let ip = \"123.57.2.144\";\r\n  wxpay.order(appId,attach,body,openId,total_fee,notify_url,ip).then((result)=>{\r\n    res.json(util.handleSuc(result));\r\n  }).catch((result)=>{\r\n    res.json(util.handleFail(result.toString()))\r\n  });\r\n})复制代码这里的流程请参见 官方描述 。官方描述的非常清楚，这儿就不描述更多了，其实主要就是拼接一些参数，获取 签名 。然后根据签名加上其他需要的 参数 (参见上述代码)再凭借xml的数据。然后再调用统一下单接口 https://api.mch.weixin.qq.com/pay/unifiedorder 。生成 prepay_id之后，生成小程序端需要的一些参数，然后把这些参数返回个小程序客户端，供小程序的客户端调用微信小程序的支付功能。小程序前端支付非常简单，只是简单的调用服务端提供的 payWallet 接口，传入 openId 和 money 即可。然后获取到相应的参数，调用微信提供的 requestPayment 拉起支付即可。主要代码逻辑如下：pay() {\r\n    app.get(Api.payWallet,{\r\n      openId: Store.getItem('openId'),\r\n      money: this.data.index\r\n    }).then((res) => {\r\n      // 支付\r\n      wx.requestPayment({\r\n        timeStamp: res.timeStamp,\r\n        nonceStr: res.nonceStr,\r\n        package: res.package,\r\n        signType: res.signType,\r\n        paySign: res.paySign,\r\n        success: function (errmsg) {\r\n          if (errmsg == 'requestPayment:ok') {\r\n            wx.showToast({\r\n              title: '支付成功',\r\n              icon: 'success'\r\n            });\r\n          }\r\n        },\r\n        fail: function (res) {\r\n          if (res.errMsg == 'requestPayment:fail cancel') {\r\n            wx.showToast({\r\n              title: '支付取消',\r\n              icon: 'none'\r\n            });\r\n          } else {\r\n            wx.showToast({\r\n              title: res.errmsg,\r\n              icon: 'none'\r\n            });\r\n          }\r\n        }\r\n      })\r\n    });\r\n  }\r\n复制代码到这里，小程序端的支付功能就已经实现了。"}
{"title": "微信小程序加入购物车动画的实现（向上、向下） ", "author": "Rolan", "pub_time": "2020-1-14 00:42", "content": "场景描述：一般情况下，加入购物车的动画效果都会是上图的3的路线，在这篇文章里，我们来实现1和2路线的加入购物车的动效（3路线的动画效果网上有很多，具体可以参考这篇文章来实现： www.cnblogs.com/greengage/p… ）。实现方式：不管是上图中的哪一种效果，我们都是用CSS3里的cubic-bezier（三次贝塞尔曲线）来实现的。具体什么是三次贝塞尔曲线，可以参考这篇文章： www.bbsmax.com/A/RnJWwpbRJ…#实现流程：1、获取屏幕的高度大小wx.getSystemInfo({//  获取页面的有关信息\r\n      success: function (res) {\r\n        wx.setStorageSync('systemInfo', res)\r\n        var ww = res.windowWidth;\r\n        var hh = res.windowHeight;\r\n        that.globalData.ww = ww;\r\n        that.globalData.hh = hh;\r\n      }\r\n    });\r\n复制代码2、获取点击的位置（购物车的位置我们定为最上方或者最下方），定义移动距离/*加入购物车动效*/\r\n  _flyToCartEffect: function (events) {\r\n    //获得当前点击的位置，距离可视区域左上角\r\n    var touches = events.touches[0];\r\n    var diff = {\r\n      x: '25px',\r\n      y: app.globalData.hh -touches.clientY-40 + 'px'//向下\r\n      // y: 25- touches.clientY  + 'px'//向上\r\n\r\n    },\r\n      style = 'display: block;-webkit-transform:translate(' + diff.x + ',' + diff.y + ') rotate(350deg) scale(0)';  //移动距离\r\n    this.setData({\r\n      isFly: true,\r\n      translateStyle: style\r\n    });\r\n    var that = this;\r\n    setTimeout(() => {\r\n      that.setData({\r\n        isFly: false,\r\n        translateStyle: '-webkit-transform: none;',  //恢复到最初状态\r\n        isShake: true,\r\n      });\r\n      setTimeout(() => {\r\n        var counts = that.data.cartTotalCounts + that.data.productCounts;\r\n        that.setData({\r\n          isShake: false,\r\n          cartTotalCounts: counts\r\n        });\r\n      }, 200);\r\n    }, 1000);\r\n  },\r\n复制代码3、在css里调用beizer函数.fiexd-cart.animate{\r\n  animation: aCartScale 200ms cubic-bezier(.17,.67,.83,.67);\r\n  animation-fill-mode: backwards;\r\n}\r\n复制代码aCartScale是，在曲线的最后，实现了个购物车抖动的动画@-webkit-keyframes aCartScale{\r\n  0%{\r\n    -webkit-transform: scale(1.1);\r\n  }\r\n  100% {\r\n    -webkit-transform: scale(1);\r\n  }\r\n}\r\n复制代码至此，流程全部介绍完毕，下面是全部的代码（里面可能有一些没用的css样式代码，读者可以自行根据需要删除）：js代码：var app = getApp();\r\nPage({\r\n\r\n  /**\r\n   * 页面的初始数据\r\n   */\r\n  data: {\r\n    isFly:false\r\n  },\r\n\r\n  /*添加到购物车*/\r\n  onAddingToCartTap: function (events) {\r\n    //防止快速点击\r\n    if (this.data.isFly) {\r\n      return;\r\n    }\r\n    this._flyToCartEffect(events);\r\n  },\r\n  /*加入购物车动效*/\r\n  _flyToCartEffect: function (events) {\r\n    //获得当前点击的位置，距离可视区域左上角\r\n    var touches = events.touches[0];\r\n    var diff = {\r\n      x: '25px',\r\n      y: app.globalData.hh -touches.clientY-40 + 'px'//向下\r\n      // y: 25- touches.clientY  + 'px'//向上\r\n\r\n    },\r\n      style = 'display: block;-webkit-transform:translate(' + diff.x + ',' + diff.y + ') rotate(350deg) scale(0)';  //移动距离\r\n    this.setData({\r\n      isFly: true,\r\n      translateStyle: style\r\n    });\r\n    var that = this;\r\n    setTimeout(() => {\r\n      that.setData({\r\n        isFly: false,\r\n        translateStyle: '-webkit-transform: none;',  //恢复到最初状态\r\n        isShake: true,\r\n      });\r\n      setTimeout(() => {\r\n        var counts = that.data.cartTotalCounts + that.data.productCounts;\r\n        that.setData({\r\n          isShake: false,\r\n          cartTotalCounts: counts\r\n        });\r\n      }, 200);\r\n    }, 1000);\r\n  },\r\n\r\n})\r\n复制代码wxml代码：<view class=\"container detail-container\">\r\n  <view class=\"fixed-btns-box\" bindtap=\"onCartTap\">\r\n    <view class=\"fiexd-cart {{isShake?'animate':''}}\">\r\n      <image src=\"../../imgs/icon/cart@top.png\"></image>\r\n      <view wx:if=\"{{cartTotalCounts>0}}\">{{cartTotalCounts}}</view>\r\n    </view>\r\n  </view>\r\n\r\n  <view \r\n  style=\"position: fixed;right: 50rpx;bottom:100rpx;width: 100rpx;\"\r\n  class=\"add-cart-btn {{product.stock==0?'disabled':''}}\" bindtap=\"onAddingToCartTap\">\r\n    <text style=\"width: 360rpx\">加入分享</text>\r\n    <image class=\"cart-icon\" src=\"../../imgs/icon/cart.png\"></image>\r\n    <image id=\"small-top-img\" class=\"small-top-img {{isFly?'animate':''}}\" src=\"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1575871576&di=dda9d07660c88bea6553c3279b0a8cf0&imgtype=jpg&er=1&src=http%3A%2F%2Fpic.pc6.com%2Fup%2F2011-9%2F2011926155953.jpg\"\r\n      mode=\"aspectFill\" style=\"{{translateStyle}}\"></image>\r\n  </view>\r\n\r\n\r\n  \r\n\r\n  <view class=\"fixed-btns-box2\" bindtap=\"onCartTap\">\r\n    <view class=\"fiexd-cart {{isShake?'animate':''}}\">\r\n      <image src=\"../../imgs/icon/cart@top.png\"></image>\r\n      <view wx:if=\"{{cartTotalCounts>0}}\">{{cartTotalCounts}}</view>\r\n    </view>\r\n  </view>\r\n\r\n</view>\r\n复制代码wxss代码：.detail-container {\r\n  background-color:#F9F9F9\r\n}\r\n.detail-header-box,.detail-bottom-box{\r\n  background-color: #fff;\r\n}\r\n.detail-topic-img{\r\n  display: flex;\r\n  justify-content: center;\r\n}\r\n.detail-topic-img image{\r\n  width: 100%;\r\n}\r\n\r\n.fixed-btns-box{\r\n  position: fixed;\r\n  top:50rpx;\r\n  right:12px;\r\n  width: 80rpx;\r\n\r\n}\r\n.fixed-btns-box2{\r\n  position: fixed;\r\n  right:12px;\r\n  width: 80rpx;\r\n  bottom: 50rpx;\r\n\r\n}\r\n.fiexd-cart image{\r\n  height: 64rpx;\r\n  width: 64rpx;\r\n}\r\n.fiexd-cart view{\r\n  font-size: 24rpx;\r\n  background-color: #AB956D;\r\n  color: white;\r\n  position: absolute;\r\n  right: 64rpx;\r\n  top: 0rpx;\r\n  height: 36rpx;\r\n  width: 36rpx;\r\n  line-height: 36rpx;\r\n  border-radius: 36rpx;\r\n  text-align: center;\r\n}\r\n.fiexd-cart.animate{\r\n  animation: aCartScale 200ms cubic-bezier(.17,.67,.83,.67);\r\n  animation-fill-mode: backwards;\r\n}\r\n\r\n@-webkit-keyframes aCartScale{\r\n  0%{\r\n    -webkit-transform: scale(1.1);\r\n  }\r\n  100% {\r\n    -webkit-transform: scale(1);\r\n  }\r\n}\r\n\r\n\r\n\r\n.product-counts,.add-cart-btn{\r\n  height: 100%;\r\n  display: flex;\r\n  font-size: 24rpx;\r\n  align-items: center;\r\n  justify-content: center;\r\n}\r\n.product-counts{\r\n  width: 50%;\r\n}\r\n.add-cart-btn{\r\n  position: relative;\r\n  flex: 1;\r\n}\r\n.add-cart-btn:active{\r\n  color: #fff;\r\n}\r\n.add-cart-btn.disabled{\r\n  color: #D5D5DB;\r\n}\r\n\r\n\r\n\r\n.small-top-img{\r\n  height: 160rpx;\r\n  width: 160rpx;\r\n  right:6rpx;\r\n  position: absolute;\r\n  opacity: 0;\r\n}\r\n.small-top-img.animate{\r\n  opacity: 1;\r\n  -webkit-transition:all 1000ms cubic-bezier(0.175, 0.885, 0.32, 1.275);\r\n}\r\n\r\n\r\n\r\n\r\n.add-cart-btn .cart-icon{\r\n  margin-left: 40rpx;\r\n  height: 32rpx;\r\n  width: 32rpx;\r\n}\r\n\r\n\r\n.disabled{\r\n    pointer-events: none;\r\n}\r\n\r\n复制代码"}
{"title": "微信小程序开发系列教程第七章：编辑名片页面开发 ", "author": "admin", "pub_time": "2016-10-12 22:14", "content": "编辑名片有两条路径，分为新增名片流程与修改名片流程。用户手填新增名片流程：首先跳转到我们的新增名片页面 1 需要传递用户的当前 userId，wx.navigateTo 带值跳转。Manual 为 true 设置用户走的是新增路线。新增名片页面 1 基本布局如下：取到 userId。使用微信自带的 input 组件验证也非常好用，如 maxLength 属性，可以限制用户输入长度，如我这的姓名长度是最大 5 位，直接数字 5 即可。也可以自定义一些验证效果，具体可以根据需求进行一些验证配置，取到用户输入的值，进行操作。这里绑定了自带的模态框提示组件。其中 modalHidden2 是模态框开关。另外 proptText 是需要提示的内容。即使很多输入框也支持数据动态改变，非常方便。实际效果，非常快捷，比以前省去很多事情，编写小程序，发现最大的好处可能就是我们不必去考虑一系列兼容性问题。最后还有个头像上传图片，测试了下目前上传到后台服务器还有点问题，应该是内测版本不太完善导致吧。设置的直接是背景图片。提交表单与跳转。提交表单使用的是自带的 bindsubmit 事件组件，在 button 组件上添加 formType=”submit” 即可，还有点需注意的是使用表单提交功能时 input 需加上 name 属性，这个传递方式是以键值对的形式传递的。这时候跳转到编辑页 2 页面，这个页面是根据用户填写的手机号码识别到匹配的公司，页面非常简单，一个数据循环而已，单选框日后可能还需要美化一下。同样也是一些数据绑定以及验证效果。实际渲染效果可以看到。这个和第一个编辑页面逻辑基本不相上下，一些基本验证与提交，这里就讲到前面两步骤即可，编辑页面3也是同理，这里不再过多啰嗦。修改名片流程效果图与需求，修改名片是一次性把以前填写的个人信息全部渲染出来，供用户来改动：名片图片模块，上传图片暂时还有点问题，这里就是模仿了个跳转组件，比较建议需要跳转的页面还是使用 wx.navigateTo 控制好一点，wx.navigateTo 提供了给我们不同的 3 个跳转路由，封装的都很好，而且跳转页面很多牵连到传值之类的，可以达到统一管理也可以避免一些看不到的 bug 吧，总之还是根据业务需求来定：姓名手机必填模块：个人信息模块，直接循环（block）出来：Onload 时我们请求必填与选填数据：* requiredGroup 必填中文信息* notRequiredGroup 选题中文信息* requiredGroupEn 必填英文信息* notRequiredGroupEn 选题英文信息```//请求名片对应的公司的中文信息的属性组数据，分为必填和选填//选题项变量以 no 开头requester.getOfflineCardInfoGroupFields(userId, cardId,function (res) {//debuggervar userName = res.card.userName;var mobile = res.card.mobile;var requiredGroup = res.requiredGroupCh;var notRequiredGroup = res.notRequiredGroupCh;var requiredGroupEn = res.requiredGroupEn;var notRequiredGroupEn = res.notRequiredGroupEn;var reqLen = requiredGroup.fields.length;var nreqLen = notRequiredGroup.fields.length;var reqLenEn = requiredGroupEn.fields.length;var nreqLenEn = notRequiredGroupEn.fields.length;self.setData({userName: userName,mobile: mobile,requireFields: requiredGroup.fields,notRequireFields: notRequiredGroup.fields,requireFieldsEn: requiredGroupEn.fields,notRequireFieldsEn: notRequiredGroupEn.fields,l1: reqLen,l2: nreqLen + reqLen,l3: reqLenEn + nreqLen + reqLen});self.forceUpdate();}, function (code, msg) {console.info(\"code=\" + code + \"&msg=\" + msg);});```中英文信息必填与选填渲染：这里表单提交数据转换有点复杂（大家根据业务需求来做，不必花时间研究这里的方法），获取的是数组，按照后台需要的数据格式进行转换传递过去。今天再回去理下首页 A、B、C 定点跳转功能实现方法。首先是右边小索引布局以及数据绑定，数据绑定和名片夹列表上的字母一样，该字母下面有名片则渲染出来，没有则不需要渲染，id同样是当前字母与右边显示的内容一样：数据 sort，和 group.name 数据一样：这里是因为 # 不支持设为 id（就是 id=”#”），故而进行了一个转化。点击事件：获取到当前 ID，以及绑定数据 toView 为当前 ID。首先名片列表，名片上的字母索引都在 scroll-view 里面，这个 scroll-view 必须设置好固定的高度，设置成 100% 与 100vh 是无效的，y 轴的滚动开关打开，scroll-into-view 需要跳转到它子元素的 id 上。可以看下：这个 group.name==sortmsg，等于就是 A==A,B==B 同理。在这里如顶部有些菜单栏的话，你就要注意好布局了，不然会出现向下偏移这个菜单栏的高度，其实你只要和字母索引同级下即可避免此问题（这里的顶部菜单以模板分离出去了，分离模板的时候需注意下，需要在这里绑定模板的一些数据会出现失效，具体没有继续深入研究下去）。跳转功能基本实现（ohter 就是 # 底部）。"}
{"title": "小程序技能进阶回忆录 - 如何自主实现拦截器 ", "author": "Rolan", "pub_time": "2019-10-23 00:23", "content": "窗外，是5月明媚的阳光，澄澈蔚蓝的天空，有炮弹欢快地叫着飞过。50多年过去了，我依然如此清晰地记得。在一些框架中发现会提供一个很实用的功能：拦截器（interceptor）。例如要实现这个需求：小程序每次获取到定位后都存到\tglobalData 里：wx.getLocation({\r\n  // ..\r\n  success(res) {\r\n    getApp().globalData.location = res\r\n    // ...\r\n  }\r\n})\r\n复制代码如果每一处使用\twx.getLocation 的地方都这么写也没啥大问题，但总显得不够“智能”，一方面是多了重复代码，另一方面如果需求变动，获取到定位后存到别的地方，那要改很多次。优雅的拦截器有了拦截器，可以更优雅的实现它：intercept('getLocation', {\r\n  success(res) {\r\n    getApp().globalData.location = res\r\n  }\r\n})\r\n复制代码只要在一处定义如上的拦截器，其他地方直接用\twx.getLocation 即可。那么，如何实现上面的方式呢？实现 intercept 方法// utils/intercept.js\r\n// 存储拦截器定义\r\nvar interceptors = {}\r\nfunction intercept(key, config) {\r\n  intercept[key] = config\r\n}\r\nexport {\r\n  intercept,\r\n  interceptors\r\n}\r\n复制代码很简单，暴露出\tintercept 方法，定义一个存储器也一并暴露出去。代理 wx要实现使用\twx.getLocation 自动应用拦截器，就必须基于原有方法重新定义它。import { interceptors } from './intercept'\r\n\r\n// 备份原有微信方法\r\nvar wxBackup = {}\r\n[\r\n  'getLocation'\r\n  // 还可以有很多其他方法 ...\r\n].forEach((key) => {\r\n  wxBackup[key] = wx[key]\r\n  wx[key] = (config) => {\r\n    if (interceptors[key]) {\r\n      // 备份业务代码传入的回调方法\r\n      var backup = {}\r\n      var interceptor = interceptors[key]\r\n      [\r\n        'success',\r\n        'fail',\r\n        'complete'\r\n      ].forEach((k) => {\r\n        backup[k] = config[k]\r\n        config[k] = (res) => {\r\n          interceptor[k](res)\r\n          backup[k](res)\r\n        }\r\n      })\r\n    }\r\n    wxBackup[key](config)\r\n  }\r\n})\r\n复制代码当然，上述代码用数组列出了所有可能被定义拦截器的微信函数，也可以使用\tObject.keys(wx) 通用处理。更多使用场景上面的场景比较简单，拦截器的应用还有更多场景。比如每次请求传参带上公参经纬度，接口返回的数据都会约定包裹在\tobject 中，请求回来需要取一遍。数据异常时还要针对错误码做特定处理，就可以很方便的用拦截器处理：intercept('request', {\r\n  data(data) {\r\n    var location = getApp().globalData.location\r\n    data.location = location.latitude + ',' + location.longitude\r\n    return data\r\n  },\r\n  success(res) {\r\n    if (res.code == 200) {\r\n      return res.object\r\n    } else {\r\n      if (res.code == 'xxx') {\r\n        // 登录失效，重新登录\r\n        // ....\r\n      }\r\n    }\r\n  }\r\n})\r\n复制代码注意，拦截器函数里多了返回值，具体实现方法就不多写，基于上述实现完善代码即可。总结细心的读者可能发现，我们代理或者改造了很多微信提供的方法，有些开发者可能不喜欢这样，希望保持原有代码的纯洁性。这要看团队喜好吧，基于此考虑，主要是不想定义太多新的方法或 api，尽量以大家最为熟悉的方式书写代码。"}
{"title": "小程序多端差异调研报告(微信，支付宝，头条，QQ) ", "author": "Rolan", "pub_time": "2019-11-4 00:32", "content": "已经使用uni-app开发并发布了一个跨端小程序啦，嘻嘻嘻！须知这是一份详细的小程序各特性各端真机调研对比报告测试机：iPhone7 plus IOS 12.4.1客户端：微信7.0.5，支付宝10.1.72，今日头条7.4.0，抖音8.1.0，QQ8.1.5.461:no_entry_sign:️ 百度小程序只有商户才能注册，个人开发者无法注册，没有appid功能受限（如百度开发者工具无法使用预览功能导致无法真机测试），所以暂时不测百度小程序用户信息授权授权方式：【\t头条 】用户信息授权方式还停留在微信小程序第一版，即直接调用 getUserInfo 弹出授权弹窗，如果用户选择\t允许 ，则后续调用不再出弹窗，而是直接走 success 回调。如果用户选择\t取消 ，则后续调用也不再出弹窗，而是直接走 fail 回调【\t微信 】【QQ】【\t支付宝 】则采用 button + 回调事件的方式调起授权弹窗，如果用户选择\t允许 ，则后续点击不再出弹窗，直接走回调。如果用户选择\t取消 ，则后续点击继续弹窗询问授权授权信息清除方式：【微信】删除小程序即可清除授权信息【支付宝】我的-设置-安全设置-账号授权【今日头条】我的-系统设置-清除缓存。【抖音】未找到清除方法【QQ】未找到清除方法（据说开放小程序的QQ版本尚未灰度发布）小程序登录【微信】\twx.login【QQ】\tqq.login 基本同微信【支付宝】\tmy.getAuthCode【\t头条 】大致同微信，未找到模型文档分享行为：【微信】直接调起聊天对话列表进行选择【QQ】调起分享渠道列表：QQ好友QQ空间点右上角三个点调起的列表还有微信好友和朋友圈两个项，在微信中打开qq小程序是走中间页【\t支付宝 】调起分享渠道列表：支付宝朋友圈支付宝联系人微信好友|QQ好友(保存支付宝生成的分享图片后打开支付宝扫码)钉钉好友(中间页自动打开支付宝小程序，中间页不自动关闭)新浪微博(中间页自动打开支付宝小程序，和钉钉一个中间页)【\t头条 】调起分享渠道列列表：转发到头条微信好友|微信朋友圈(生成口令，复制口令后打开今日头条弹出识别弹窗)QQ|QQ空间(打开中间页，点击打开(QQ空间点了没反应)，出现另一个中间页，自动打开AppStore，再点打开调起今日头条，最后居然没打开那个小程序 !!!)【抖音】调起分享渠道列列表：多闪好友微信好友|微信朋友圈|QQ好友|QQ空间(生成抖音码图片，打开抖音扫码识别)【头条】\twebview的转发暂未支持 ：【今日头条】能转发，但转发的链接点击后总是提示加载失败！也可能是小程序未发布的原因，扫\tuni-app官方demo 进行 webview转发是能正常打开的【抖音】不支持转发，右上角胶囊只有一个关闭按钮跳转到其他小程序【微信】\t支持 (navigateToMiniProgramAppIdList + navigateToMiniProgram)【QQ】\t支持【头条】\t支持 (navigateToMiniProgramAppIdList + navigateToMiniProgram)【支付宝】\t支持 (后台配置 + navigateToMiniProgram):no_entry_sign:️ ️QQ，支付宝和头条未真机验证，因为须要一个其他小程序的appId客服会话【微信】支持(\tbutton open-type=\"contact\" )【QQ】支持，须用户加一个客服机器人为好友【支付宝】支持(\tcontact-button )【头条】\t不支持 。支付【微信】\t支持 (调起微信支付)【QQ】\t支持 (调起QQ支付)【支付宝】\t支持 (调起支付宝支付)【头条】\t支持 (调起支付宝App进行支付):no_entry_sign: ️QQ，支付宝和头条未真机验证，因为支付接口只有商户才有权限地理位置【微信】\t支持 (\t须在app.json中配置permission字端 )，用户拒绝授权后再次调用不再出询问弹窗，而是直接走fail回调【QQ】支持。真机行为同微信。QQ开发者工具上拒绝授权再次调用仍会出询问弹窗【头条】\t支持 ，同微信【支付宝】\t支持 ，用户拒绝授权后再次调用继续出询问弹窗视频播放【微信】\t支持【QQ】支持【头条】\t支持【支付宝】支持？(\tuni-app里说 支付宝不支持，\t支付宝文档 也没找到video组件，但放在页面里video能正常渲染和播放，难道是昨天刚支持 )复制文字行为：【微信】【QQ】复制成功后有一个默认的复制成功toast且无法控制【支付宝】【头条】复制成功后没有toast权限：【支付宝】\tmy.setClipboard 此功能仅支持企业支付宝账号。实际情况是：在IDE上个人账号是可以复制的，但在真机上调用就会报\tERROR 4: 无权调用该接口 错误【微信】【QQ】【头条】无限制打电话【微信】【QQ】【支付宝】【头条】都支持收货地址【微信】\t支持【QQ】不支持【头条】\t支持 （实测【今日头条】支持，【抖音】不支持）【支付宝】\t支持 。但仅商户才有使用权限。且目前 my.getAddress 接口暂不支持在开发者工具调试和真机调试，仅支持真机预览相机/图片相关拍照/相册选图片【微信】【QQ】支持【支付宝】支持。IDE上会弹一个相册授权询问弹窗，真机上并没有弹窗【头条】支持。但会弹出两个询问弹窗（相机权限，相册权限）拍摄/相册选视频【微信】【QQ】支持【支付宝】支持。IDE上会弹一个相册授权询问弹窗，真机上并没有弹窗。须调用 my.chooseVideo(文档未找到)，uni.chooseVideo会报错【头条】支持。但会弹出两个询问弹窗（相机权限，相册权限）:warning:chooseVideo的maxDuration选项在【微信】和【支付宝】是只限制拍摄时长，在【头条】是同时限制相册选择视频时长和拍摄时长图片预览【微信】【QQ】【支付宝】【头条】都支持保存图片到相册【微信】【QQ】【头条】支持，弹窗仅询问一次【支付宝】\ttt.saveImageToPhotosAlbum 在IDE上报错\ttt.saveImageToPhotosAlbum is not a function ，在真机上报错\t无权调用该接口 ，文档未提及，猜测是仅商户可用，且不支持在开发者工具调试和真机调试，仅支持真机预览接口返回值差异getUserInfo【\t微信 】【\tQQ 】【\t支付宝 】【\t头条 】// 支付宝\r\n{\r\n  'nickName': 'test',\r\n  'gender': 'm',\r\n  'city': '北京市',\r\n  'province': '北京'\r\n  'countryCode': 'CN',\r\n  'avatar': 'https:\\/\\/tfs.alipayobjects.com\\/images\\/partner\\/T1_38eXnRiXXXXXXXX',\r\n  'code': '10000',\r\n  'msg': 'Success',\r\n}\r\n// 微信\r\n{\r\n  'nickName': 'test',\r\n  'gender': 1,\r\n  'city': 'Xinxiang',\r\n  'province': 'Henan',\r\n  'country': 'China',\r\n  'avatarUrl': 'https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJCzUl7llykqrMLicpULvVfkbbL2bVDua4tI8ibjxq5E9ib1oPW3F4QazLIUdS2GsFMAGnrWSYjN05Ew/132'\r\n  'language': 'zh_CN',\r\n}\r\n// QQ\r\n{\r\n  'nickName': 'test',\r\n  'gender': 1,\r\n  'city': '新乡',\r\n  'province': '河南'\r\n  'country': '中国',\r\n  'avatarUrl': 'https://thirdqq.qlogo.cn/qqapp/1108100302/D64611B2AE700324589177922EEBA5F4/100',\r\n  'language': 'zh_CN',\r\n}\r\n// 头条系（今日头条，抖音，皮皮虾，西瓜视频分别取各自用户信息）\r\n{\r\n  'nickName': 'test',\r\n  'gender': 1,\r\n  'city': '新乡市',\r\n  'province': '河南省'\r\n  'country': '中国',\r\n  'avatarUrl': 'http://wx.qlogo.cn/mmhead/Q3auHgzwzM5uibSytRCXFs0Y3xSpdy12thibjWIoMrBIsf7FiaPp2ibnFg/0',\r\n  'language': '',\r\n}getSetting【\t微信 】【\t支付宝 】【\t头条 】【\tQQ 】// 微信 https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/authorize.html\r\n[\r\n  'scope.userInfo', // 用户信息\r\n  'scope.userLocation', // 地理位置\r\n  'scope.address', // 通讯地址\r\n  'scope.record', // 录音功能\r\n  'scope.camera', // 摄像头\r\n  'scope.writePhotosAlbum', // 保存到相册\r\n\r\n  'scope.userLocationBackground', // 后台定位\r\n  'scope.invoiceTitle', // 发票抬头\r\n  'scope.invoice', // 获取发票\r\n  'scope.werun', // 微信运动步数\r\n]\r\n// 头条 https://developer.toutiao.com/dev/miniapp/uQjMy4CNyIjL0IjM\r\n[\r\n  'scope.userInfo', // 用户信息\r\n  'scope.userLocation', // 地理位置\r\n  'scope.address', // 通讯地址\r\n  'scope.record', // 录音功能\r\n  'scope.camera', // 摄像头\r\n  'scope.album',  // *保存到相册*\r\n]\r\n// 支付宝 https://docs.alipay.com/mini/api/xmk3ml#-1\r\n[\r\n  'userInfo', // 用户信息\r\n  'location', // 地理位置\r\n  'audioRecord', // 录音功能\r\n  'camera', // 摄像头\r\n  'album', // 保存到相册\r\n]\r\n// QQ https://q.qq.com/wiki/develop/game/frame/open-ability/authorize.html\r\n[\r\n  'scope.userInfo', // 用户信息\r\n  'scope.userLocation', // 地理位置\r\n  'scope.qqrun', // QQ运动步数\r\n  'scope.writePhotosAlbum', // 保存到相册\r\n  'scope.appMsgSubscribed', // 订阅消息\r\n]主要入口【微信】首屏对话列表下拉扫一扫发现->小程序搜索【支付宝】扫一扫搜索首页我的小程序【今日头条】我的->扫一扫搜索【抖音】搜索->扫一扫【QQ】扫一扫:bomb: 头条小程序陷阱目前仅在头条Android版本7.2.9及以上版本支持真机调试功能。iOS暂时不支持真机调试抖音App的小程序上没有打开调试器选项，右上角胶囊只有一个关闭按钮:bomb: 支付宝小程序陷阱my.getOpenUserInfo 用于获取支付宝会员基础信息，\t只能在真机上调试，无法在 IDE 中调试 ，也就是只要有用户授权的页面都需要推送到真机上开发调试！支付宝授权平台只返回tocken和uid，由\t开发者自己维护session有效期 ，\tcheckSession 方法不可用打开调试的调试器面板在调起用户授权弹窗时会消失，此时须使用真机调试:bomb: uni-app 陷阱uni.getSetting ，文档上说【支付宝】支持，调用却报错\t支付宝小程序，暂不支持getSetting，而直接调支付宝的api\tmy.getSetting 确是支持的uni.chooseVideo ，文档上说【支付宝】支持，调用却报错\t支付宝小程序，暂不支持chooseVideo ，而直接调支付宝的api my.chooseVideo(文档未找到) 确是支持的uni.chooseAddress ，文档上说【支付宝】不支持，实际上是支持的，只是需要调用\tmy.getAddress ，且仅商户才能使用uni.getImageInfo ，文档上说【头条】支持，调用却报错\t头条小程序，暂不支持getImageInfo，而直接调头条的api\ttt.getImageInfo 确是支持的:pushpin: TODO模版消息第三方插件uni-app 跨端小程序风险点后端接口。不同端的后端接口不一样，需要后端评估一下。举例：模版消息(\t微信 |\t支付宝 |头条 )；设计用户系统时需注意微信和QQ都有各自的openID和unionID，支付宝只有uid，头条只有openID；接入微信，QQ，支付宝支付时各种传参不一样分享转发。支付宝，头条小程序分享至微信和QQ的主要方式是生成口令或者生成小程序码图片或者走中间页，导致传播路径较长某些端重要功能缺失。举例：【头条】不支持客服会话。【抖音】不支持webview转发。【QQ】不支持收货地址某些端api缺失，可能导致某些功能无法实现第三方插件支持度"}
{"title": "微信小程序swiper组件非居中对称滑动解决方案 ", "author": "Rolan", "pub_time": "2019-11-12 00:02", "content": "一、前言在公司的项目中遇到了非居中对称的类banner滑动需求，如下图：每次滑动的距离并非一屏的宽度，而是要根据实际情况来控制。二、解决方案一开始看文档，由于swiper组件的配置项并不多，我估计能解决这个需求的大概只有previous-margin，next-margin和display-multiple-items三个参数。在经过一系列尝试之后，放弃了display-multiple-items这个参数，如果使用这个参数，很多时候基本上触发不了bindchange事件，并不符合预期也不合理。于是开始研究previous-margin和next-margin，previous-margin可以露出前一项的一小部分，next-margin可以露出后一项的一小部分。于是在初始化时，我把previous-margin设置为28，next-margin设置为400，就可以完美展现图banner1的效果。（slide宽度为300rpx）<swiper\r\n  class=\"swiper-container\"\r\n  previous-margin=\"{{swiperDis.previous}}rpx\"\r\n  next-margin=\"{{swiperDis.next}}rpx\"\r\n  bindchange=\"handleSwiperChange\"\r\n>\r\n  <block wx:for=\"{{ImgList}}\" wx:key=\"{{index}}\">\r\n    <swiper-item class=\"slide-item\">\r\n      <navigator>\r\n        <view class=\"slide-content\">\r\n          <image class=\"slide-bg\" src=\"{{item.bg}}\" />\r\n        </view>\r\n      </navigator>\r\n    </swiper-item>\r\n  </block>\r\n</swiper>swiperDis设置为：swiperDis: {\r\n  previous: 28,\r\n  next: 400\r\n}这时候如果滑动的话，会发现后面两个slier并不如我们所想，而是每次都会滑到最前面，所以我就想如果我在每次bindchange的时候改变previous-margin和next-margin呢？于是我加入了这种傻瓜式的代码：handleSwiperChange(e) {\r\n  const currentIndex = e.detail.current\r\n  if(currentIndex == 0) {\r\n    this.setData({\r\n      swiperDis: {\r\n        previous: 28,\r\n        next: 400\r\n      }\r\n    })\r\n  }else if(currentIndex == 1) {\r\n    this.setData({\r\n      swiperDis: {\r\n        previous: 214,\r\n        next: 214\r\n      }\r\n    })\r\n  }else if(currentIndex == 2) {\r\n    this.setData({\r\n      swiperDis: {\r\n        previous: 400,\r\n        next: 28\r\n      }\r\n    })\r\n  }\r\n}得到的效果如我所想。唯一不够完美的就是这样设置不如swiper自适应滑动的效果那么自然，稍微有那么一点点的卡顿，但我觉得在没有更好的解决办法前这是个又快速又好的方法。"}
{"title": "uni-app对微信小程序云函数的适配 ", "author": "Rolan", "pub_time": "2019-11-20 00:05", "content": "版权说明本文首发于个人博客-指尖魔法屋（www.thinkmoon.cn)。原文地址： uni-app对微信小程序云函数的适配引言熟悉uni-app的人应该都知道，uni-app并未对微信小程序云函数（本文统称云函数）进行相应的适配。但是，如果我们在某些业务场景的下需要使用云函数呢？我们知道，云函数可以复制到微信开发者工具，这样的话我们不得不每次编译一次就手动复制一次，不得不说麻烦至极。本文就问题做出以下解决方案。本文环境Hbuilder X微信开发者工具创建云函数目录首先，我们需要在uni-app项目文件夹下，创建一个云函数目录，路径随意，我这里是 functions 。然后先随便在里面放一些文件，这里以 new_file.css 为例。修改 manifest.json在uni-app根目录下，修改 manifest.json 中的微信小程序项，结构如下\"mp-weixin\" : {\r\n        /* 小程序特有相关 */\r\n        \"appid\" : \"wxd7de467f6e6cf741\",\r\n        \"cloudfunctionRoot\": \"./functions/\", // 这一行就是标记云函数目录的字段\r\n        \"setting\" : {\r\n            \"urlCheck\" : false\r\n        },\r\n        \"usingComponents\" : true\r\n    }编写 vue.config.jsvue.config.js\r\nconst path = require('path')\r\nconst CopyWebpackPlugin = require('copy-webpack-plugin')\r\n\r\nmodule.exports = {\r\n    configureWebpack: {\r\n        plugins: [\r\n            new CopyWebpackPlugin([\r\n                {\r\n                    from: path.join(__dirname, 'functions'),\r\n                    to: path.join(__dirname, 'unpackage/dist', process.env.NODE_ENV === 'production' ? 'build' : 'dev', process.env.UNI_PLATFORM, 'functions')\r\n                }\r\n            ])\r\n        ]\r\n    }\r\n}编译运行发现提示如下内容说明未安装 copy-webpack-plugin 插件，我们手动安装一下。然后编译运行，发现微信开发者工具里面出现以下内容。截止目前，已打通Hbuilder X到微信开发者工具的自动复制，即已解决本文的核心内容。以下为进一步测试。创建云函数我们在云函数根目录上右键，在右键菜单中，可以选择创建一个新的 Node.js 云函数，我们将该云函数命名为check。开发者工具在本地创建出云函数目录和入口 index.js 文件，同时在线上环境中创建出对应的云函数。创建成功后，工具会提示是否立即本地安装依赖，确定后工具会自动安装 wx-server-sdk。我们会看到以下内容。创建好后将其同步复制到uni-app项目，即可为以后自动同步行方便，又可避免在输出文件夹中云函数的意外丢失。至此，相关文件编写工作转至 Hbuilder X ，云函数上传部署依旧在微信开发者工具。编写云函数默认的云函数只是一个返回用户基本数据的内容，我们将其修改至满足我们的业务需求，以内容安全云调用为例。在云函数文件中写入以下内容// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\n\r\ncloud.init()\r\n\r\n// 云函数入口函数\r\nexports.main = async(event, context) => {\r\n  try {\r\n    console.log('待检测文本:' + event.content);\r\n    let result = await cloud.openapi.security.msgSecCheck({\r\n      content: event.content\r\n    })\r\n    console.log('result:' + JSON.stringify(result));\r\n\r\n    if (result && result.errCode.toString() === '87014') {\r\n      return {\r\n        code: 300,\r\n        msg: '内容含有违法违规内容',\r\n        data: result\r\n      }\r\n    } else {\r\n      return {\r\n        code: 200,\r\n        msg: 'ok',\r\n        data: result\r\n      }\r\n    }\r\n\r\n  } catch (err) {\r\n    if (err.errCode.toString() === '87014') {\r\n      return {\r\n        code: 300,\r\n        msg: '内容含有违法违规内容',\r\n        data: err\r\n      }\r\n    }\r\n    return {\r\n      code: 400,\r\n      msg: '调用security接口异常',\r\n      data: err\r\n    }\r\n  }\r\n}权限申明在函数目录下，创建一个 config.json ,文档说会自动创建，但是我实际操作时未自动创建。 config.json 内容如下。{\r\n    \"permissions\": {\r\n        \"openapi\": [\r\n            \"security.msgSecCheck\"\r\n        ]\r\n    }\r\n}然后在函数目录右键，上传并部署。小程序调用云函数wx.cloud.init()\r\n                wx.cloud.callFunction({\r\n                    name: 'check',\r\n                    data: {\r\n                        \"content\": this.contents.join()\r\n                    }\r\n                }).then(res => {\r\n                    console.log(res.result)\r\n                    if (res.result.code == 300) {\r\n                        uni.showModal({\r\n                            title: \"温馨提示\",\r\n                            content: \"你所输入的内容可能含有违法违规内容，不支持进行下一步操作\"\r\n                        })\r\n                        return\r\n                    } else {\r\n                        ... // 你要进行的操作\r\n                    }\r\n                })效果展示"}
{"title": "小程序包大小优化(uni-app) ", "author": "Rolan", "pub_time": "2019-11-28 00:24", "content": "在开发微信小程序的过程中，随着业务逻辑日渐庞大之后，突显了一些问题。首先我们发现在 dev mode 时，本地包大小已经达到了 4m+，这种情况下，已经无法在 dev mode 使用真机调试了。其次此时，小程序 build 后也有 1.8M 左右。而且后续还有相当多的业务需求需要开发，包大小肯定会更大。这时候就想要优化小程序包大小。下面分享一下我的定位过程和解决思路。尽管我们使用 uni-app 开发，但思路是通用的，希望能给大家一些帮助吧。如何减小包大小代码分析首先分析包大在哪儿了。打开本地代码目录查看文件大小。可以发现 common/vendor.js 和 page,components 中 js 占了大部分。在 build 编译模式下，代码压缩已经启用了，需要思考别的优化方式。这时候可以使用\twebpack-bundle-analyzer 插件\t。它可以帮助分析 vendor.js 中都有哪些 js 模块，哪些模块比较大，以便我们进一步优化代码通过这个插件，发现了下面两个问题。问题一: uni-app 自定义组件模式编译 tree shaking 无效如果不是使用 uni-app 开发可以跳过这一段通过代码分析发现有些模块应该被 tree shaking 但却被打包进来了。基本确定是 tree shaking 没有生效。同样是 webpack4 + babel7。在不使用 uni-app，直接使用 vue-cli create 项目的前提下，tree shaking 是没有问题的。而使用 uni-app 去新建项目，tree shaking 却无效。排查 babel 配置时发现是由于 uni-app 在创建项目的时候，设置了 modules: 'commonjs'导致。修改后，demo 的 tree shaking ok。但是回到项目里一编译，又出错了。继续定位发现是\tuni-app 自定义组件模式编译问题 。目前uni-app\t已经修复 了我提的bug，虽然还未正式发布。当然你不使用 uni-app 自定义组件模式编译也可以解决，uni-app 还支持\ttemplate模板模式 ，但是会有一些开发差异和性能差距，有兴趣可以看下\t这篇文章问题二：部分库不支持 tree shaking有些库(比如 lodash)本身并没有使用 import/export，所以 webpack 并不能对它们 tree shaking。这些库我们可以分情况优化。首先可以找下网上是否有库对应的 esm 版本可以替代，如 lodash-es。其次可以从代码分析中看出，如果库的每个模块都在不同文件中，入口文件只是一个统一入口，那么我们就可以通过修改写法按需加载，如import add from \"lodash/add\";\r\nimport Button from 'ant-design-vue/lib/button';\r\n复制代码我们也可以使用\tbabel-plugin-import 插件针对那些库统一实现按需加载，它的本质是在编译时统一按配置修改加载路径，不需要自己手动去修改代码。最后如果都不行，那要么接受，要么自己重写为社区做贡献~规范模块开发为了免除无法 tree shaking 的烦恼，我们在开发 npm 模块的时候也需要遵循一定的规范，从而减少模块打包后的大小。同时支持 commonjs 和 es module我们的模块需要同时支持 commonjs 和 es module。这样才能既满足 commonjs 开发的用户，又支持 tree shaking。如何实现呢？如果你的代码是 typescript,以@sentry/browser 为例，可以在编译时编译 cjs 和 esm 两种规范代码，如下// package.json\r\n\"build\": \"run-s build:dist build:esm build:bundle\",\r\n\"build:bundle\": \"rollup --config\",\r\n\"build:dist\": \"tsc -p tsconfig.build.json\",\r\n\"build:esm\": \"tsc -p tsconfig.esm.json\",\r\n复制代码然后在 package.json 中指定两个入口以及无副作用标识\"main\": \"dist/index.js\",\r\n  \"module\": \"esm/index.js\",\r\n  \"sideEffects\": false,\r\n复制代码这样当 webpack 解析模块(\t解析规则 )，就会按需优先解析 esm 目录。并且当识别到无副作用时进行 tree shaking。如果你的代码本身就是 es6，你也可以这样\"module\": \"src/index.js\",\r\n复制代码第三方自定义组件如果使用了第三方\t微信自定义组件 ，由于引用是在 json 文件，所以 webpack 在编译时并不能通过 entry 分析到相关文件，因此不会对其进行编译、压缩等。这时候就需要我们自己处理。而且由于 webpack 不处理，tree shaking 自然也无法支持，因此建议\t尽量避免 这种方式引用组件。分包小程序分包 也是一种常规的优化方案。通过分析后，可以将一些较大的页面划分为子包。如果有单页依赖第三方自定义组件，而且第三方组件还挺大，也可以考虑将该页面划分为子包。也因此\t尽量避免将第三方自定义组件放在 globalStyle ，不然没法将它放到子包去。大图不要打包小程序中的大图，尽量避免打包进来，应该放到 CDN 通过 url 加载。我们的做法是在开发时加载本地图片，在 CI/CD 环节自动化发布图片，并改写地址。如何解决真机调试问题首先还是查看编译后的文件，发现\tcommon/vendor.js 巨大，足有 1.5M。其次\tpages 和\tcomponents 也有 1.4M，而这其中占了 js 的大小又占了绝大部分。为什么 js 文件这么大呢？主要是因为在 dev mode 默认并没有压缩，当然也没有 tree shaking。我的选择是\t修改编译配置，在 dev mode 压缩 js 代码 。本地代码减少到了 2M。预览大小则是减少到了 1.4M。参考配置如下：// vue.config.js\r\n    configureWebpack: () => {\r\n        if (isDev && isMp) {\r\n            return {\r\n                optimization: {\r\n                    minimize: true,\r\n                },\r\n            }\r\n        }\r\n    }\r\n复制代码这看上去并不是个好方案，但确实简单有效。也考虑过分包，但分包并不能解决 common/vendor.js 巨大的问题，预览时包还是很大。如果有其它好的办法也欢迎留言~"}
{"title": "小程序不同页面的异步回调，callback和promise的使用讲解 ", "author": "Rolan", "pub_time": "2019-12-5 00:23", "content": "发个扫盲贴，大神请绕道。最近好多同学问我如何再请求数据成功后直接使用数据。我们通常的做法就是在请求成功后，再调用我们定义的方法，进而使用数据。如下代码  onLoad() {    let that=this    wx.cloud.database().collection(\"users\").get({      success(res) {        that.setData(res.data)      },      fail(res) {      }    })  },  showData(dataList) {    //.........做数据处理  },我们这样写其实也没什么不对，但是如果数据请求和使用是在两个不同的页面呢。 比如我们在app.js里请求位置，获取用户信息。然后在首页index.js里要使用这些数据，那么我们这么写就有问题了。下面就来教大家两种方式来很好的解决这个问题。一，通过callback回调。先看下代码，然后我再具体给大家讲解下原理。app.js里定义如下方法然后再index.js 里这么使用这时候，其实就可以看到了，我们在首页index.js里调用了app.js里的请求数据的方法，并且可以在index.js里直接使用数据。原理讲解 原理其实很简单，就是我们在app.js里的获取数据的方法里定义一个参数。而这个参数和普通参数唯一不同的地方，就是这个参数是个function方法我们上图的callback参数，其实就是下图 function(result){}把function方法作为一个参数传递进去的目的，就是为了下面的回调。我们这个callBack参数，可以在请求数据成功或者失败的时候作为一个方法调用。这样就可以把请求到的数据，回传回去了。 讲的有点绕，不知道大家有没有被绕晕。这在java开发中，其实就相当于监听者模式。说白了就是在一个页面里监听另外一个页面的动作，如获取数据成功，当监听到数据获取成功这个动作以后，就可以直接把数据回传回来了。 如果觉得这种方法有点绕，不好使用，我们就用下面的这个第二种方式。二，promisepromise的好处就是可以不用那个层层传递，不用那么绕。 还是先看代码，后面结合代码给大家讲下原理 app.js里定义如下方法index.js里这么调用用句通俗的话说，就是通过promise让我们的数据请求和使用看上去是在同一个页面完成。怎么实现的呢 1，在app.js里把数据请求封装到promise里，然后把promise返回到我们的首页index.js里 2，在首页里使用这个promise 实现数据的获取和使用。 在具体些就是下面这几步 promise基础用法1、new 一个Promise对象 2、请求数据的异步代码写在promise的函数中 3、promise接受两个参数，一个resolve(已成功success)，一个reject(已失败fail) 4、promise有三种状态pendding(进行中，当new了promise就是pendding的状态)、fulfilled(已成功)、rejected(已失败)，当成功的时候调用resolve将状态改为已成功，当失败的时候调用reject将状态改为已失败，一旦状态发生改变之后，状态就凝固了，后面就无法改变状态了，成功会将成功的数据返回，失败会将失败的信息返回。 5、在需要获取数据的地方通过promise.then()的方式获取，这里面接受两个参数，都是匿名函数，第一个是接受成功的函数，第二个是失败时候的函数好了，到这里我们两种不同页面的异步回调就给大家将完了。代码就完整的给大家贴出来吧，方便大家日后使用app.js//app.jsApp({  //第二种，通过promise  promiseGetData() {    let promise = new Promise(function(success, fail) {      wx.cloud.database().collection(\"users\").get({        success(res) {          success(res)        },        fail(res) {          fail(res)        }      })    })    return promise;  },  //第一种，通过callback的方式来实现回调  callBackGetData(callBack) {    wx.cloud.database().collection(\"users\").get({      success(res) {        callBack(res)      },      fail(res) {        callBack(res)      }    })  },})index.js// 异步调用，callbackconst app = getApp()Page({  clickBtn() { //按钮点击    //callback方式    // app.callBackGetData(function(result) {    //   console.log(\"dataList\", result)    // })    //promise方法    let promise = app.promiseGetData()    promise.then((res) => { //获取成功的结果，res中存着获取成功时的数据      console.log(\"成功\", res)    }, (error) => { // 获取数据失败时      console.log(\"失败\", error)    })  },})"}
{"title": "微信小程序文本展开/收起功能 ", "author": "Rolan", "pub_time": "2019-12-19 00:44", "content": "微信小程序中，有时候文本需要实现这样的功能 1、文本超过n行显示省略号 2、省略时，显示 展开/收起 按钮 3、文本不超过n行时，不显示省略号和展开/收起按钮 实现思路文本过长显示省略号、展开和收起功能，通过css样式即可实现 判断是否显示展开/收起按钮： 通过嵌套元素，可以实现text既显示省略号，其高度又是全显示时的高度 通过SelectorQuery选择器，获取text及其父元素的高度，判断text高度是否超过其父元素高度，决定是否显示展开/收起按钮即可代码wxss.frame {  width: 100%;  max-height: 206rpx;  text-align: left;  display: -webkit-box;  overflow: hidden;  text-overflow: ellipsis;  word-wrap: break-word;  white-space: normal !important;  -webkit-line-clamp: 3;  -webkit-box-orient: vertical;}.nofold {  display: block;  text-overflow: unset;  -webkit-line-clamp: unset;  max-height: unset;}frame样式设置最大高度，超过3行后出现省略号。overflow为hidden，使得text的超出父元素部分隐藏掉。nofold样式则将最大高度、出现省略号的行数去除，以展示全文。wxml<view id=\"frame\" class='frame {{fold == false ? \"nofold\":\"\"}}'>    <text id=\"content\">{{detail}}</text></view>wxml中，在view元素中嵌套text元素。样式写在view中，text不加任何样式（重要）。分别写上id，方便js代码获取其尺寸信息。 javascriptvar query = this.createSelectorQuery();query.select('#content').boundingClientRect();query.select('#frame').boundingClientRect();query.exec(function(res) {  if (res[0] && res[0].height) {    if (res[0].height > res[1].height) {      self.setData({        fold: true,      });    } else {      self.setData({        fold: null,      });    }  }})js代码中，通过选择器获取两者的高度，如果text高度高于view，则说明有省略文本，显示展开/收起按钮。 js的选择器如果是写在onshow/onload方法中，最好加上延迟，以防止出现判断时元素尚未渲染出来的情况。"}
{"title": "给你的头像加个圣诞帽吧 ", "author": "Rolan", "pub_time": "2019-12-31 00:43", "content": "看着大伙都在弄这个，我自己也来试一哈，我分别用了两种方式来实现，一种是普通的方式，一种是wxs方式\r\n普通方式\r\n效果图如下：\r\n\r\n思路\r\n\r\n获取头像\r\n选择素材\r\n缩放，移动，旋转素材\r\n生成canvas\r\n生成图片，保存图片\r\n\r\n实现方式\r\n\r\n首先是获取头像，这个不用说，大家应该都会的。\r\n选择素材这里我准备了三张圣诞帽的素材，这个网上有很多，可以自己找下，然后我还做了一个选择手机相册的功能，如果你自己有素材的话也可以直接选择这个功能。\r\n缩放，移动，旋转素材都是通过触摸函数去实现的，这里是先将布局做好，然后在标签上面绑定各个触摸事件，通过返回的值在标签的style里设置实现各个效果。\r\n调整好了之后点击保存头像会获取所有参数并将头像画出来，再通过 wx.canvasToTempFilePath() 将canvas生成图片最后通过 wx.saveImageToPhotosAlbum() 保存图片。\r\n主要代码\r\n主要的函数就是下面这几个，代码片段我会放在文末，没有什么比较难的地方，就是要注意下计算的时候不要算错就行。\r\n\r\n需要注意的点\r\n由于素材的大小可能会有不同，所以在重新选择素材的时候高度要重新设置一下，这里我用了一个方法来重置高度，主要是每次重新选择素材的时候就用 wx.getImageInfo() 这个api去获取图片素材的宽高，再计算出宽高比。\r\n\r\nwxs实现方式\r\n实现方式\r\n思路跟普通方式是一样的，不同的是这里将绑定事件通过 wxs 去实现，直接设置标签的参数而不通过逻辑层去处理，在性能上会比较好一点，不过这种实现方式在进行旋转的时候最后生成的图片会有不准，后面会说到。\r\n参数的获取是通过在标签上设置style，然后点击保存的时候用  wx.createSelectorQuery() 获取各个参数的\r\n\r\n获取旋转的值\r\n由于 wx.createSelectorQuery() 并不能获取到 rotate 这个参数，所以我是通过下面这种方式来拿到旋转的值的，将旋转值以宽度的形式赋值给 .vo-ro\r\n\r\n但是我发现旋转之后生成的图片不是正确的，原因是旋转之后通过 wx.createSelectorQuery() 拿到的宽高并不是图片大小的宽高，而是旋转之后的宽高，按理来说不应该是这样的，即使通过样式旋转，它的宽高应该保持不变才对，这样就造成了参数上的错误，所以画出来的图片是不准确的。\r\n因为加了旋转之后画出来的图片会不准确，暂时想不出别的方法，我把旋转的按钮先注释掉了，只支持缩放跟拖拽。\r\n总结\r\n两种方式，wxs性能要更好，但是效果没第一种的好，看你要哪种了，最后祝大家圣诞节快乐，祝你生活愉快\r\ndevelopers.weixin.qq.com/s/Cizd1RmY7…"}
{"title": "微信小程序使用自定义组件导航实现当前页面高亮 ", "author": "Rolan", "pub_time": "2020-1-2 00:18", "content": "最近开发小程序，需要做一个导航，导航可以通过template写出来，但是这个项目需要在导航中处理一些逻辑，做成组件更方便些。首先新建header文件夹，里面新建对应的js、json、wxml、wxss文件。<!-- 公共头部组件 -->\r\n<view class='headers'>\r\n     <navigator open-type=\"redirectTo\" class='logo' url=\"../index/index\" hover-class=\"none\">\r\n        <image src=\"../../assets/img/logo2.png\" mode=\"widthFix\"></image>\r\n     </navigator>\r\n    <view class=\"phone_nav_switch\" bindtap=\"controlNav\">\r\n        <view class=\"iconfont icon-daohang\" hidden=\"{{navIsShow}}\"></view>\r\n        <view class=\"iconfont icon-guanbi\" hidden=\"{{!navIsShow}}\"></view>\r\n    </view>\r\n    <view class=\"nav\">\r\n        <view class=\"shadow {{navIsShow ? 'active':''}}\" bindtap=\"controlNav\"></view>\r\n        <view class=\"bg {{navIsShow ? 'active':''}}\">\r\n            <view class='con' wx:for=\"{{navs}}\" wx:key=\"item.url\">\r\n                 <navigator open-type=\"redirect\" data-index=\"{{index}}\" class=\"{{index === navActive ? 'active' : ''}}\" url=\"{{item.url}}\" hover-class=\"none\">\r\n                    {{item.text}}\r\n                 </navigator>\r\n            </view>\r\n        </view>\r\n    </view>\r\n    <!-- 返回顶部 -->\r\n    <view class=\"backTop\" bindtap=\"goTop\" hidden='{{floorstatus}}'>\r\n        <text class=\"icon iconfont icon-iconfonticontrianglecopy\"></text>\r\n    </view>\r\n\r\n</view>header.js里的导航数据/**\r\n   * 组件的属性列表\r\n   */\r\n  properties: {\r\n    // 当前导航高亮\r\n    navActive: {\r\n      // 类型\r\n      type: Number,\r\n      // 默认值\r\n      value: 0\r\n    }\r\n  },\r\n\r\n  data: { \r\n    // 导航开关 \r\n    navIsShow: false,\r\n    currentIndexNav: 0,\r\n    // floorstatus: false,\r\n    navs: [\r\n      {\r\n        text: '网站首页',\r\n        url: '../index/index'\r\n      },\r\n      {\r\n        text: '招商加盟',\r\n        url: '../join/join'\r\n      },\r\n      {\r\n        text: '关于煮田',\r\n        url: '../about/about'\r\n      },\r\n      {\r\n        text: '煮田美食',\r\n        url: '../food/food'\r\n      },\r\n      {\r\n        text: '最新资讯',\r\n        url: '../news/news'\r\n      },\r\n      {\r\n        text: '门店查询',\r\n        url: '../search/search'\r\n      },\r\n      {\r\n        text: '联系我们',\r\n        url: '../contact/contact'\r\n      },\r\n      {\r\n        text: '视频列表',\r\n        url: '../videoItem/videoItem'\r\n      }\r\n\r\n    ]\r\n  },导航放在class=\"nav\"中，header.json文件中写入{\r\n  \"component\": true\r\n}需要引入组件的页面的json文件写入，比如index.json{\r\n  \"component\": true,\r\n  \"usingComponents\": {\r\n    \"header\":\"../header/header\"\r\n  }\r\n}然后在index.wxml引入组件,navActive是传给组件的值，目的是为了对应导航组件内的导航每一项的index，比如首页的index为0，那我在首页内定义的navActive就是0，<!-- 头部组件 -->\r\n    <view class='header'> \r\n        <!-- 导航高亮传值 -->\r\n         <header navActive='0'></header>\r\n    </view>如果相等当前页面就会高亮需要在在heaer.js设置navActive的类型，通过上面的操作，我是能够实现当前页面导航高亮的，希望能帮到需要的人，如果觉得我上面写的不清楚的话，这是我的githubhttps://github.com/mazixiao/w...,这个是我做好了的"}
{"title": "微信小程序canvas生成海报 文字自动换行 canvas高度动态设置 ", "author": "Rolan", "pub_time": "2020-1-2 00:24", "content": "在微信小程序中分享，官网只提供分享给好友和群聊的能力，未提供分享到朋友圈的api。因此小程序分享到朋友圈通常做法就是利用canvas生成一张动态海报，上面贴一个小程序码图片，分享到朋友圈，长按识别小程序码进入小程序，以达到在朋友圈推广小程序的功能。初始化canvas1.在.wxml中 创建一个canvas, canvasWidth 和 canvasWidth 分别为创建的canvas的宽高。比如我们需要保存的海报尺寸为750px * 1350px; 我们就可以设置canvasWidth = 750；canvasWidth = 1350；这样导出来的图片比较清晰。<view class=\"canvas-box\">\r\n    <canvas canvas-id=\"canvas\" class=\"canvas\" style=\"width: {{canvasWidth}}px; height: {{canvasHeight}}px;\"></canvas>\r\n<view>2.在小程序中canvas层级最高。因此我们需要隐藏canvas,在窗口中不可见。.canvas-box{  \r\n  position: fixed;  \r\n  top: 1000px;  \r\n  left: 1000px;  \r\n  z-index: -10;  \r\n}在js中获得canvas上下文const ctx = wx.createCanvasContext('canvas'); // canvas-id绘制图片小程序绘制图片的api比较简单，一般可直接使用下面的方式const img = '/assets/images/bg.png';\r\nconst imgX = 0;      // 绘制图片在canvas中起点X坐标\r\nconst imgY = 0;      // 绘制图片在canvas中起点Y坐标\r\nconst imgWidth = 0;  // 绘制图片在canvas中宽度\r\nconst imgHeight = 0; // 绘制图片在canvas中高度\r\nctx.drawImage(img, imgX, imgY, canvasWidth, canvasHeight);本地图片小程序绘制本地图片可直接使用，例如上面的 /assets/images/bg.png' 可直接绘制到canvas上面。网络图片小程序不能直接绘制网络图片到canvas中。1.需要通过 wx.getImageInfo 获取图片信息或 wx.downloadFile 下载到本地。2.获取图片信息。网络图片需先配置download域名才能生效。如果需要绘制微信用户头像，也需要将腾讯的域名加入到白名单。这里使用wx.getImageInfo，在页面初始化的时候就请求所有需要绘制到canvas的网络图片.const localImgInfo = {}; // 存储所有网络图片请求到本地的对象\r\nconst imgList = [  \r\n  img1,\r\n  avatar,\r\n];  \r\nimgList.forEach((item, index) => {  \r\n  wx.getImageInfo({  \r\n    src: item,  \r\n  success: function (res) {  \r\n      // 保存到本地数组  \r\n  localImgInfo[item] = res.path;  \r\n  }  \r\n  })  \r\n})\r\n\r\n... (确保网络图片加载完毕后)绘制网络图片\r\n\r\nctx.drawImage(localImgInfo[avatar], imgX, imgY, canvasWidth, canvasHeight);绘制文字ctx.setFontSize(30);          // 文本字体大小\r\nctx.setFillStyle(\"#E1E6F0\");  // 颜色\r\nconst text = '我是文字';\r\nconst textX = 0;  \r\nconst textY = 0;\r\n\r\nctx.fillText(text, textStartX, textY);绘制文字和图片有一个小区别需要注意一下，起始的x,y坐标不一致。绘制图片的x,y坐标是从图片的 左上角 开始计算位置的。绘制文字的x,y坐标是从文字的 右下角 开始计算位置的。文字自动换行ctx.measureText() 能够获取canvas中文字的宽度，可通过此方法手动给文字换行// 将文字绘制到行 长文本自动换行 并返回行数  \r\n/\\*  \r\n\\* params  \r\n\\* @text 需要绘制的文本字符  \r\n\\* @startX 第一行文本的起始X坐标  \r\n\\* @startY 第一行文本的起始Y坐标  \r\n\\* @lineHeight 文本行高  \r\n\\* @MAX\\_WIDTH 单行文字最大宽度，超过临界值自动换行  \r\n\\*  \r\n\\* return rowLength 返回绘制文本的行数  \r\n\\* \\*/\r\nfunction drawText(text, startX, startY, lineHeight, MAX\\_WIDTH) {  \r\n  let allAtr \\= text.split('');  \r\n  let rowArr \\= \\[\\]; // 拆分出来的每一行  \r\n  let rowStrArr \\= \\[\\]; // 每一行的文字数组  \r\n  for (let i \\= 0; i < allAtr.length; i++) {  \r\n    const currentStr \\= allAtr\\[i\\];  \r\n  rowStrArr.push(currentStr);  \r\n  const rowStr \\= rowStrArr.join('');  \r\n  if (ctx.measureText(rowStr).width \\> MAX\\_WIDTH) {  \r\n      rowStrArr.pop(); // 删除最后一个  \r\n  rowArr.push(rowStrArr.join('')); // 完成一行  \r\n  rowStrArr \\= \\[currentStr\\];  \r\n  continue;  \r\n  }  \r\n    // 最后一个字母 直接添加到一行  \r\n  if (i \\=== allAtr.length \\- 1) {  \r\n      rowArr.push(rowStr); // 完成一行  \r\n  }  \r\n  }  \r\n  \r\n  for (let i \\= 0; i < rowArr.length; i++) {  \r\n    ctx.fillText(rowArr\\[i\\], startX, startY \\+ i \\* lineHeight);  \r\n  }  \r\n  return rowArr.length;  \r\n}drawText() 函数主要的作用就是绘制传入的文本，使用 ctx.measureText() 判断单行文字的宽度是否超过单行最大宽度，如果超过就将ctx绘制文本的startY坐标设置为当前startY+文本行高，实现切换到下一行的效果canvas高度动态设置由于项目中生成的海报图片高度随内容变化，导致不同的内容生成的海报高度不一致，所以这边只需要将canvas的高度放在data中，然后根据不同的内容动态计算最终海报的高度，然后设置data中canvas的高度即刻。下面是项目中的实际效果，在这里，海报由三个部分组成，头部，内容，底部。其中头部和底部高度固定，中间的内容高度由后台返回的书籍数量决定，其中可能需要换行的就是书籍的名称和副标题。这里简单的将每一本书作为一块区域，高度固定，因此 内容区域的高度 = 书籍数量 * 书籍高度，通过此方法简单计算出中间内容区的高度，然后动态设置canvas的高度。源码https://github.com/zhaosheng808/canvasPoster提供简单的微信小程序测试号demo，包含请求用户保存canvas图片的授权逻辑。测试号需要将不校验合法域名打开，不然无法下微信头像和外部图片。正式号需要在微信公众平台配置下载域名"}
{"title": "微信小程序长按保存图片 ", "author": "Rolan", "pub_time": "2020-1-2 00:43", "content": "微信浏览器打开h5页面如果是img标签的话，长按会弹出保存图片的选项。但是微信小程序里面不可以，需要自己写这个功能。这个功能有两个点，一个是长按，一个是保存图片到本地。1. 微信小程序关于图片长按的解释，有两种：因此我们选用 bindlongpress 事件2. 微信小程序同样提供了保存图片的接口，是wx.saveImageToPhotosAlbum()3. 值得说的是，保存的接口，两个需要注意的地方：1、需要先授权，调用 wx.getSetting()方法2、保存的图片路径参数，不支持网络路径，而在我们渲染页面时，用到的图片有很大可能是网络路径，这时候我们需要先把网络路径转为可用的本地路径，wx.getImageInfo()方法可以满足需要4. 最后再走个心吧，毕竟我这么可爱1、长按后直接保存未免潦草了些，考虑到用户体验，加入 wx.showActionSheet()2、如果用户拒绝授权 或者 以前拒绝过授权，这时候也应该给他提示，或者展示再次打开授权的入口将将！然后就可以开始写代码了：<image src=\"{{url}}\" data-url=\"{{url}}\" bindlongpress=\"saveImage\"></image>// 长按保存功能--授权部分\r\nsaveImage (e) {\r\n    let _this = this\r\n    wx.showActionSheet({\r\n        itemList: ['保存到相册'],\r\n        success(res) {\r\n            let url = e.currentTarget.dataset.url;\r\n            wx.getSetting({\r\n                success: (res) => {\r\n                    if (!res.authSetting['scope.writePhotosAlbum']) {\r\n                        wx.authorize({\r\n                            scope: 'scope.writePhotosAlbum',\r\n                            success: () => {\r\n                                // 同意授权\r\n                                _this.saveImgInner(url);\r\n                            },\r\n                            fail: (res) => {\r\n                                console.log(res);\r\n                                wx.showModal({\r\n                                    title: '保存失败',\r\n                                    content: '请开启访问手机相册权限',\r\n                                    success(res) {\r\n                                        wx.openSetting()\r\n                                    }\r\n                                })\r\n                            }\r\n                        })\r\n                    } else {\r\n                        // 已经授权了\r\n                        _this.saveImgInner(url);\r\n                    }\r\n                },\r\n                fail: (res) => {\r\n                    console.log(res);\r\n                }\r\n            })   \r\n        },\r\n        fail(res) {\r\n            console.log(res.errMsg)\r\n        }\r\n    })\r\n},\r\n// 长按保存功能--保存部分\r\nsaveImgInner (url) {\r\n    wx.getImageInfo({\r\n        src: url,\r\n        success: (res) => {\r\n            let path = res.path;\r\n            wx.saveImageToPhotosAlbum({\r\n                filePath: path,\r\n                success: (res) => {\r\n                    console.log(res);\r\n                    wx.showToast({\r\n                        title: '已保存到相册',\r\n                    })\r\n                },\r\n                fail: (res) => {\r\n                    console.log(res);\r\n                }\r\n            })\r\n        },\r\n        fail: (res) => {\r\n            console.log(res);\r\n        }\r\n    })\r\n},文章写的比较正序，参考的是这篇倒序文章，喜欢倒序的筒子们可以去看下这篇： https://www.jianshu.com/p/e59...（虽然很痛恨没有视频效果的文章，可是录好了视频的我 实在找不到上传视频的按钮！我好难！！！）"}
{"title": "小程序wifi能力解读与实践 ", "author": "Rolan", "pub_time": "2020-1-3 00:28", "content": "背景\r\n小程序wifi系列接口为系统原生能力。早在2015年，微信就推出了「微信连Wi-Fi」，微信连Wi-Fi是为商家的线下场所提供一套完整和便捷的微信连Wi-Fi的方案。现在已经是一套完整的，便捷的解决方案。顾客通过扫码的方式连接wifi，同时微信还可以向用户下发消息。方案在官方文档已经阐述得很详细，本文就不再赘述。本文重点在于讲解小程序中使用wifi能力遇到的问题和心得。\r\n【微信连wifi】传送门\r\nwifi能力解读\r\nwifi能力简介\r\n在小程序中，使用wifi模块都需要先调用wx.startWifi()来初始化wifi模块。以下能力的使用均需要在wx.startWifi的success回调中使用。\r\n连接wifi\r\nwx.connectWifi({\r\n    SSID: 'mx 的iphone', // Wi-Fi 设备 SSID\r\n    BSSID: '', // Wi-Fi 设备 BSSID\r\n    password: 'xxxxxxxx',\r\n    success(){},\r\n    fail(){},\r\n    complete(){}\r\n})\r\n复制代码connectWifi为我们提供了直连wifi的能力， 仅 Android 与 iOS 11 以上版本支持，需要基础库1.6.0以上。这个一般是我们使用wifi功能的核心API了。在ios中，会出现系统弹框，询问用户是否要连接wifi，只有用户点击确定，connectWifi才会继续进行，否则就走fail回调了。在安卓（以小米note3为例，Anroid9）中则会出现微信连一连的toast。\r\n获取当前已经连接的wifi\r\nwx.getConnectedWifi({\r\n    success(WifiInfo){\r\n        // WifiInfo\r\n    }\r\n})\r\n复制代码从社区中获取的信息得知：signalStrength表示信号强度，iOS 是系统返回的，取值 0-1，安卓经过转换，取值 0-100。数值与信号强度为正比例关系。\r\n获取wifi列表\r\nwx.getWifiList({\r\n    success(e) {\r\n        wx.onGetWifiList((res) {\r\n            // res.wifiList:wifiInfo[]\r\n        })\r\n    }\r\n})\r\n复制代码获取周围的wifi列表，需要先使用getWifiList后使用onGetWifiList进行监听。在ios中，getWifiList会跳到ios系统界面，这是由于ios系统的限制， 目前是无法避免的（其实这么做也无可厚非，wifi信息本来就是敏感的，但是对用户体验有一定的影响）。在安卓中，getWifiList需要获取用户的位置信息，因为可以利用小程序嗅探周边Wi-Fi热点来推断用户所在的位置信息。为了确保用户的隐私不受侵犯，自微信android客户端 7.0.4 起，需要先获取用户地理位置（scope.userLocation）。详情请见wx.getWifiList接口需获取用户位置信息授权后使用\r\n设置AP相关信息\r\nwx.onGetWifiList(function(res) {\r\n    wx.setWifiList({\r\n      wifiList: [{\r\n        SSID: res.wifiList[0].SSID,\r\n        BSSID: res.wifiList[0].BSSID,\r\n        password: '123456'\r\n      }]\r\n    })\r\n})\r\n复制代码\r\n这个接口也挺牛逼，ios特有的。通过设置wifiList，我们在系统页可以直接看到已设置的wifi列表，点了就直接连上了。\r\n其他\r\n\r\nwx.stopWifi 关闭wifi模块\r\nwx.onWifiConnected(function callback)监听连接上 Wi-Fi 的事件\r\nwx.offWifiConnected 取消监听连接上 Wi-Fi 的事件\r\nwx.offGetWifiList(function callback) 取消监听获取到 Wi-Fi 列表数据事件。\r\n\r\n安卓连接wifi\r\n连接指定 Wi-Fi 接口调用时序：\r\nAndroid：startWifi —> connectWifi —> onWifiConnected\r\n复制代码连周边 Wi-Fi 接口调用时序：\r\nAndroid：startWifi —> getWifiList —> onGetWifiList —> connectWifi —> onWifiConnected\r\n复制代码IOS连接wifi\r\n连接指定 Wi-Fi 接口调用时序：(与安卓一致)\r\niOS（仅iOS 11及以上版本支持）：startWifi —> connectWifi —> onWifiConnected\r\n复制代码连周边 Wi-Fi 接口调用时序：\r\niOS（iOS 11.0及11.1版本因系统原因暂不支持）：\r\nstartWifi —> getWifiList —> onGetWifiList —> setWifiList —> onWifiConnected\r\n复制代码实践\r\n笔者在项目中接触到了使用小程序提供的硬件（wifi）能力的场景。利用wifi与socket的能力，我们可以为物联网设备连接wifi。流程如下:\r\n\r\n刚好在开发者社区找到类似的代码片段：\r\n\r\n小程序跟设备数据传输(websocket);\r\n小程序跟设备数据传输(udpsocket);\r\n\r\n\r\nwx.request/wx.connectSocket/wx.uploadFile/wx.downloadFile 的 url 参数允许为 {PORT}/${PATH} 的格式，当且仅当 IP 与手机 IP 处在同一网段且不与本机 IP 相同（一般来说，就是同一局域网，如连接在同一个 wifi 下）时，请求/连接才会成功。\r\n在这种情况下，不会进行安全域的校验，不要求必须使用 https/wss，也可以使用 http/ws。\r\n\r\n局域网通信中，不会进行安全域校验，因此，无需在mp后台添加安全域域名。\r\n总结\r\n借助小程序提供的硬件能力(wifi,蓝牙，NFC)，小程序有了更加广阔的场景。比如【摩拜单车】小程序，有的车需要用户开一下蓝牙，小程序提供的操作原生系统的蓝牙功能便为我们赋能。通过小程序，我们也可以实现与物联网设备通信，通过连接设备热点，利用http/wss/udp传输数据。当然，现在wifi能力还是存在着问题，比如兼容问题，可能有部分安卓手机在连接时会莫名其妙的报错。此时需要对着官方提供的errcode查看具体的原因。\r\n踩过的坑\r\n\r\n安卓部分机型，已经连接wifi，使用connectWifi重新连接，即使传错密码，还是能连上。\r\nA：这个问题目前还没有解决的办法。\r\nios在getWifiList会跳到系统设置页，在connectWifi会出现modal确认是否连接。\r\nA：无法避免。ios系统的限制\r\n调试wifi功能时，无法在开发者工具中调试wifi能力。\r\nA: 目前开发者工具无法进行模拟。并且真机调试时，连接设备热点后会报错。（毕竟真机调试时需要能够访问网络，一般设备热点都不具备访问网络的能力）。目前可以通过 预览+ vconsole解决，还是比较麻烦。\r\n可以主动断开wifi吗？\r\nA: 从文档上看，没有提供这个能力。但是可以尝试连接一个不存在的wifi。\r\n来自文档的注意事项：\r\n\r\n\r\nReference\r\n\r\n微信开放文档 - wifi\r\n微信开放文档 - 局域网通信\r\n小程序WIFI接口和WebSocket创建局域网数据通讯"}
{"title": "探索小程序实现 ", "author": "Rolan", "pub_time": "2020-1-6 00:15", "content": "随着小程序的发展与功能的逐步完善，越来越多的产品需要小程序与 APP 的功能能有一些共性，社区跨平台的解决方案越来越多，比如 taro 等为代表的把一套代码编译成多端运行的机制，本文会使用 Swift 作为原生语言，在 iOS 应用上运行一个小程序 Demo， 使用 Android && React Native 也可以采用同样的思路实现。相关代码仓库： https://github.com/taixw2/rmini编译层编译的目的是为了抹平小程序的与 H5 的差异，利用 Vue 实现数据绑定，利用 Web Component 实现小程序的组件功能。从官网文档中可以看出来，运行一个小程序需要框架（数据绑定渲染）、组件（小程序渲染单元）、api（与原始交互的能力）。框架实现转换成单页应用（一种可行的方案）把所有页面打包成一个 js， 再由 js 管理所有的路由和状态，这种方案适合在 web 端运行，并且是单引擎的方案，在模拟原生的右滑返回等效果也会不尽人意。转换成多页面众所周知，小程序是一个双引擎的框架，上面的方案显然不能达到要求, 双引擎的特点是在运行 javascript 的黑盒子中，无法访问到 DOM && BOM 等。将所有的逻辑代码在原生的 JavascriptCore 中运行，WebView 中的 Javascript 引擎负责数据绑定，需要解决的难点是 JavascriptCore 中的 setData 怎么通知 WebView 渲染， WebView 的事件怎么执行 JavascriptCore，接着往下看。抹平WXMLwxml 是一种类 html 标记语言，他负责所有的渲染规则，包括条件渲染、列表渲染、数据绑定等，与其再实现一种框架，还不如直接利用 Vue 实现同样的功能，再利用各种转换库将 wxml 中的事件转换成 Vue 能够识别的事件，如利用 post-html 可以做到如下的转换:每一个事件绑定的方法全都在原生的 JSContext 中运行，所以此时的事件只需要传递给 JSContext 的作用。抹平WXSSwxss 作为小程序的样式语言，其余 css 的主要区别就是多了一个 rpx 单位，以下是官网的换算表：根据上表可得知， rpx = (750 / 屏幕宽度) * px ;在传统的移动端页面，我们的高清方案，一般需要获取 dpr， 然后修改动态修改 viewport 和 html 上的 font-size，但是小程序的代码因为是放在了设备本地，所以可以在下载小程序页面之后，我们还有一次编译机会，这时就可以把 rpx 根据当前设备的屏幕宽度替换成对应的 px。还有一个 @import ，则利用 scss 或 less 就可以合并到同一个 css 文件中,而全局样式则可以在构建 WXML 的时候再植入进入抹平组件组件具有独特的功能和自己的渲染规则，比如 scroll-view 具有 scroll-x 和 scroll-y 等属性控制滚动条。在 HTML5 中有一个重大的功能 web-component ，它能够自定义 html 元素，并且能够监控属性的变化，非常适合实现小程序组件。如：（使用了 lit-element 框架）这里用了 lit-element 这个框架，能够简化一些操作。抹平 Page 和 AppApp 负责整个应用的生命周期以及存一些全局的数据， getApp 能获取到 app 的信息。 所以类似的结构可能是这样的：getApp 能够直接访问到内部对象，并且在最顶层声明，这样每一个的地方都能访问到 getApp。初始化一个页面都需要是实例化 PageClass, 即使再次进入（不是返回到这个页面）这个页面页需要再次重新实例化，每次实例化都需要关联一个 webviewId, 这个 ID 与原始的 webview 关联，这样每个 PageClass 中的 setData 都能找到对应的 webview 进行再次渲染，所以对应的代码可能是这样的：抹平 API通过 API 能够直接调用原生的功能，比如 wx.request ， 如果直接在 webview 中的 JSContext 中运行的话，则可能存在跨域，但是放在原生就不会存在这个问题。实现JSContext 调用原生代码的功能，需要给 JSContext 中植入一个 JSBridge，如： JSBridge.invoke 和 JSBridge.on , invoke 负责同步任务，on 负责异步任务，原生再利用反射（原生的反射真麻烦）调用对应的原生方法，原生可以利用 while(true) 挂起 JSContext，既可以达到同步和异步的方法。打包 JavascriptJavascript 代码打包后被放在 JavascriptCore 中运行，唯一与 Webview 中的 JSContext 打交道的只有 setData , 先看一下打包流程：利用 App.json 构建入口文件利用 rollup 等工具将所有 Javascript 打包成一个文件（目前没有分包）打包流程及其简单，接下来看一下两个 Javascript 引擎的交互过程。打通 JSContext 到 WebView JavascriptCore每次进入一个页面的时候都需要为这个页面的 webview 分配一个 id, 这个 id 至关重要，作为 native 与 JSContext (原生运行 javascript 的上下文对象) 与 webview 交互的唯一标识，JSContext 中需要实例化一个新的 PageClass 关联这个 id， native 中通过 id 保留 webview 的引用。在 JSContext 中植入一个 JSBridge 用于与原生交互，如： JSBridge.setData(webviewId, appId, data), 当 JSBridge 的 setData 被调用后，通过 appId + webviewId 就能找到对应的 webview, 再将 setData 传入 webview 中，在 Vue 接收到 data 后进行渲染， 整个过程如图：打通 Webview JavascriptCore 到 JSContext有了前面的铺垫，接下来再看 webview 如何调用 JSContext 的方法， Webview 唯一能与 JSContext 交互的方式只有事件，事件触发后，需要通过某种方式触发 JSContext 中的方法，最后调用 setData 再返回来重新渲染 webview。webview 中绑定的方法名众多，如： bindtap=\"a\", bindtap=\"b\", bindtap=\"c\" 等，但是可以通过 “抹平 WXML” 的时候最终只保留一个出口，如:v-on:click=\"callClick('a', $event)\" 等，这样 vue 中的 method 只需要实现对应的几个事件便可：结尾利用原生作为桥梁，在两个引擎之间通信，webview 中的 JSContext 负责接收渲染通知，以及发送事件到 Native 的 JSContext 中，JSContext 独立运行，所以既访问不到 window 对象，也访问不到 document 对象。"}
